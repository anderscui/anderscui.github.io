<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 7.3.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.7.2/css/all.min.css" integrity="sha256-dABdfBfUoC8vJUBOwGVdm8L9qlMWaHTIfXt+7GnZCIo=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"anderscui.github.io","root":"/","images":"/images","scheme":"Muse","darkmode":false,"version":"8.23.1","exturl":false,"sidebar":{"position":"left","width_expanded":320,"width_dual_column":240,"display":"post","padding":18,"offset":12},"hljswrap":true,"codeblock":{"theme":{"light":"default","dark":"stackoverflow-dark"},"prism":{"light":"prism","dark":"prism-dark"},"copy_button":{"enable":false,"style":null},"fold":{"enable":false,"height":500},"language":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"duration":200,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"i18n":{"placeholder":"Searching...","empty":"We didn't find any results for the search: ${query}","hits_time":"${hits} results found in ${time} ms","hits":"${hits} results found"},"path":"/search.xml","localsearch":{"enable":true,"top_n_per_article":1,"unescape":false,"preload":false}}</script><script src="/js/config.js" defer></script>

    <meta name="description" content="时光中的碎片">
<meta property="og:type" content="website">
<meta property="og:title" content="mathacker">
<meta property="og:url" content="https://anderscui.github.io/page/3/index.html">
<meta property="og:site_name" content="mathacker">
<meta property="og:description" content="时光中的碎片">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="Anders Cui">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="https://anderscui.github.io/page/3/">


<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":true,"isPost":false,"lang":"en","comments":"","permalink":"","path":"page/3/index.html","title":""}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>mathacker</title>
  








  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous" defer></script>
<script src="/js/utils.js" defer></script><script src="/js/motion.js" defer></script><script src="/js/sidebar.js" defer></script><script src="/js/next-boot.js" defer></script>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-generator-searchdb/1.4.1/search.js" integrity="sha256-1kfA5uHPf65M5cphT2dvymhkuyHPQp5A53EGZOnOLmc=" crossorigin="anonymous" defer></script>
<script src="/js/third-party/search/local-search.js" defer></script>







  





  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">mathacker</h1>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">no math, little hacker</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="Search" role="button">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>About</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>Tags</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>Categories</a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>Search
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
      <div class="search-header">
        <span class="search-icon">
          <i class="fa fa-search"></i>
        </span>
        <div class="search-input-container">
          <input autocomplete="off" autocapitalize="off" maxlength="80"
                placeholder="Searching..." spellcheck="false"
                type="search" class="search-input">
        </div>
        <span class="popup-btn-close" role="button">
          <i class="fa fa-times-circle"></i>
        </span>
      </div>
      <div class="search-result-container">
        <div class="search-result-icon">
          <i class="fa fa-spinner fa-pulse fa-5x"></i>
        </div>
      </div>
    </div>
  </div>

</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Anders Cui</p>
  <div class="site-description" itemprop="description">时光中的碎片</div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">34</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">11</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">26</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author animated">
      <span class="links-of-author-item">
        <a href="https://github.com/anderscui" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;anderscui" rel="noopener me" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
  </div>

        </div>
      </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner index posts-expand">

    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://anderscui.github.io/2019/05/12/python-coroutines/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Anders Cui">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="mathacker">
      <meta itemprop="description" content="时光中的碎片">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | mathacker">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2019/05/12/python-coroutines/" class="post-title-link" itemprop="url">Python中的协程</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2019-05-12 02:53:25" itemprop="dateCreated datePublished" datetime="2019-05-12T02:53:25+08:00">2019-05-12</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2025-06-22 07:01:37" itemprop="dateModified" datetime="2025-06-22T07:01:37+08:00">2025-06-22</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Programming/" itemprop="url" rel="index"><span itemprop="name">Programming</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>本文主要整理自《Fluent Python》的第16章。</p>
<p>David Beazley（又）尝言，协程是py文档中最语焉不详、模糊的，看起来是一个毫无用处的特性。当然，事实并非如此，他写过关于协程与并发的系列文章：<a href="http://www.dabeaz.com/coroutines/">A Curious Course on Coroutines and Concurrency</a>。</p>
<p><code>yield</code>一次在英语中有两个主要含义：产生和让路。在生成器中，这两个含义都适用：每次产生一个值，生成器都会挂起，“让路”给调用者。</p>
<p>协程的语法看起来像是生成器，但协程一般出现在表达式的右边（如<code>datum = yield</code>），它也不一定需要产生一个值。调用者使用<code>.send()</code>时，协程接受到一个值。</p>
<p>甚至可以完全没有数据从<code>yield</code>进出，所以不妨把<code>yield</code>看作<strong>一个流程控制装置</strong>，可用于实现协作式多任务处理：每个协程交出控制给central scheduler，随后其它协程可被激活。</p>
<h1 id="协程的基本操作"><a href="#协程的基本操作" class="headerlink" title="协程的基本操作"></a>协程的基本操作</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> inspect <span class="keyword">import</span> getgeneratorstate</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">simple_coro</span>(<span class="params">a</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;-&gt; Started: a =&#x27;</span>, a)</span><br><span class="line">    b = <span class="keyword">yield</span> a</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;-&gt; Received: b =&#x27;</span>, b)</span><br><span class="line">    c = <span class="keyword">yield</span> a + b</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;-&gt; Received: c =&#x27;</span>, c)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">coro = simple_coro(<span class="number">14</span>)</span><br><span class="line"><span class="built_in">print</span>(getgeneratorstate(coro))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">next</span>(coro))</span><br><span class="line"><span class="built_in">print</span>(getgeneratorstate(coro))</span><br><span class="line"><span class="built_in">print</span>(coro.send(<span class="number">28</span>))</span><br><span class="line"><span class="built_in">print</span>(coro.send(<span class="number">99</span>))</span><br></pre></td></tr></table></figure>

<p>从调用者角度看，它获取数据的方式与生成器类似，但是它同时多了两次<code>send</code>操作，<code>send</code>比<code>next</code>多了一个方向的数据流转，但对于<code>yield</code>，它依然会挂起当前例程（此处为协程），将执行交给调用者。</p>
<h1 id="协程示例：持续计算均值"><a href="#协程示例：持续计算均值" class="headerlink" title="协程示例：持续计算均值"></a>协程示例：持续计算均值</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">averager</span>():</span><br><span class="line">    total, count = <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">    average = <span class="literal">None</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        term = <span class="keyword">yield</span> average</span><br><span class="line">        total += term</span><br><span class="line">        count += <span class="number">1</span></span><br><span class="line">        average = total / count</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">co = averager()</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">next</span>(co))</span><br><span class="line"><span class="built_in">print</span>(co.send(<span class="number">10</span>))</span><br><span class="line"><span class="built_in">print</span>(co.send(<span class="number">30</span>))</span><br><span class="line"><span class="built_in">print</span>(co.send(<span class="number">5</span>))</span><br></pre></td></tr></table></figure>

<p>实现这一功能不是非得用协程，也可以用类或闭包，但在协程里，total和count都是简单的局部变量。</p>
<p>在上面两个例子中可以看到，使用协程都需要最开始调用一次<code>next</code>，这次操作一般称为“启动”（prime）。每个协程都需要启动，而协程也是函数，所以装饰器就派上用场了。</p>
<h1 id="启动协程的装饰器"><a href="#启动协程的装饰器" class="headerlink" title="启动协程的装饰器"></a>启动协程的装饰器</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> functools <span class="keyword">import</span> wraps</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">coroutine</span>(<span class="params">func</span>):</span><br><span class="line"><span class="meta">    @wraps(<span class="params">func</span>)</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">primer</span>(<span class="params">*args, **kwargs</span>):</span><br><span class="line">        gen = func(*args, **kwargs)</span><br><span class="line">        <span class="built_in">next</span>(gen)</span><br><span class="line">        <span class="keyword">return</span> gen</span><br><span class="line">    <span class="keyword">return</span> primer</span><br></pre></td></tr></table></figure>

<h1 id="协程的终止与异常处理"><a href="#协程的终止与异常处理" class="headerlink" title="协程的终止与异常处理"></a>协程的终止与异常处理</h1><p><code>.throw()</code>与<code>.close()</code>。</p>
<h1 id="协程的返回值"><a href="#协程的返回值" class="headerlink" title="协程的返回值"></a>协程的返回值</h1><p>协程是生成器函数，因此可以有返回值，此时协程必须是正常终止的，比如<code>while</code>break之后。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://anderscui.github.io/2019/05/10/python-iterables/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Anders Cui">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="mathacker">
      <meta itemprop="description" content="时光中的碎片">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | mathacker">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2019/05/10/python-iterables/" class="post-title-link" itemprop="url">Python中的可迭代类型</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2019-05-10 22:26:38" itemprop="dateCreated datePublished" datetime="2019-05-10T22:26:38+08:00">2019-05-10</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2025-06-22 07:01:37" itemprop="dateModified" datetime="2025-06-22T07:01:37+08:00">2025-06-22</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Programming/" itemprop="url" rel="index"><span itemprop="name">Programming</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>本文主要整理自《Fluent Python》的第14章。</p>
<p>**迭代（iteration）**在数据处理中不可或缺的。当数据在内存中放不下时，我们需要偷一下懒（lazily），每次按需取一个数据项，这就是所谓的迭代器（iterator）模式。</p>
<p>Python 2.2（2001）添加了<code>yield</code>关键字，用以构造<strong>生成器（generator）</strong>，生成器可达成迭代器的效果。而且，在Python社区中，生成器与迭代器同义。</p>
<p>Python中的每个集合（collection）都是<strong>可迭代的（iterable）</strong>。迭代器在内部用于：</p>
<ul>
<li>for 循环</li>
<li>集合类型的构造与扩展</li>
<li>列表等类型的推导</li>
<li>tuple unpacking</li>
<li>*args的unpacking</li>
</ul>
<p>本章涵盖以下主题：</p>
<ul>
<li><code>iter</code>函数</li>
<li>如何实现经典的迭代器模式</li>
<li>生成器工作机制</li>
<li>经典的迭代器可用生成器替代</li>
<li><code>yield from</code>语句</li>
<li>生成器与**协程（coroutine）**看起来相似，本质上却非常不同</li>
</ul>
<h1 id="序列类型1：词序列"><a href="#序列类型1：词序列" class="headerlink" title="序列类型1：词序列"></a>序列类型1：词序列</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line"><span class="keyword">import</span> reprlib</span><br><span class="line"></span><br><span class="line">RE_WORD = re.<span class="built_in">compile</span>(<span class="string">&#x27;r\w+&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Sentence</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, sentence</span>):</span><br><span class="line">        <span class="variable language_">self</span>.sentence = sentence</span><br><span class="line">        <span class="variable language_">self</span>.words = RE_WORD.findall(sentence)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__getitem__</span>(<span class="params">self, item</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">self</span>.words[item]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__len__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">len</span>(<span class="variable language_">self</span>.words)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__repr__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="string">f&#x27;Sentence(<span class="subst">&#123;reprlib.<span class="built_in">repr</span>(self.sentence)&#125;</span>)&#x27;</span></span><br><span class="line">        </span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    sent = Sentence(<span class="string">&#x27;&quot;The time has come,&quot; the Walrus said,&#x27;</span>)</span><br><span class="line">    <span class="built_in">print</span>(sent)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> word <span class="keyword">in</span> sent:</span><br><span class="line">        <span class="built_in">print</span>(word)</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">list</span>(sent))</span><br><span class="line">    <span class="built_in">print</span>(sent[<span class="number">0</span>])</span><br></pre></td></tr></table></figure>

<h2 id="为何序列是可迭代的？"><a href="#为何序列是可迭代的？" class="headerlink" title="为何序列是可迭代的？"></a>为何序列是可迭代的？</h2><p>当解释器对一个对象<code>x</code>进行迭代时，它会自动调用<code>iter(x)</code>，该内置函数会：</p>
<ul>
<li>检查对象是否实现了<code>__iter__</code>，有则调用之，并获取到一个迭代器；</li>
<li>否则检查<code>__getitem__</code>，有则调用之，并创建一个迭代器；</li>
<li>否则抛出<code>TypeError</code></li>
</ul>
<p>因为<strong>序列</strong>都实现了<code>__getitem__</code>，因此它们同时也是可迭代的，而标准库中的序列类型也会同时实现<code>__iter__</code>，我们实现序列类型时也需要如此。</p>
<p>这一处理方式导致了一个有趣的事实：一个iterable的对象不一定满足<code>isinstance(o, abc.Iterable)</code>。判断对象是否可迭代的准确方式是，对其迭代并捕获异常。</p>
<h1 id="可迭代类型与迭代器类型"><a href="#可迭代类型与迭代器类型" class="headerlink" title="可迭代类型与迭代器类型"></a>可迭代类型与迭代器类型</h1><p>可迭代与迭代器的区别是，Python从iterable获取iterator。</p>
<p>下面的例子演示iterator类型的用法，不使用for循环：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">s = <span class="string">&#x27;abc&#x27;</span></span><br><span class="line">it = <span class="built_in">iter</span>(s)</span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="built_in">next</span>(it))</span><br><span class="line">    <span class="keyword">except</span> StopIteration:</span><br><span class="line">        <span class="keyword">del</span> it</span><br><span class="line">        <span class="keyword">break</span></span><br></pre></td></tr></table></figure>

<p><code>StopIteration</code>表明迭代器已经迭代结束，在使用for循环时，该异常在其内部被处理掉了。</p>
<p>Iterator接口有两个方法：<code>__next__</code>、<code>__iter__</code>。</p>
<h1 id="序列类型2：生成器函数"><a href="#序列类型2：生成器函数" class="headerlink" title="序列类型2：生成器函数"></a>序列类型2：生成器函数</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Sentence</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, sentence</span>):</span><br><span class="line">        <span class="variable language_">self</span>.sentence = sentence</span><br><span class="line">        <span class="variable language_">self</span>.words = RE_WORD.findall(sentence)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__iter__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">for</span> word <span class="keyword">in</span> <span class="variable language_">self</span>.words:</span><br><span class="line">            <span class="keyword">yield</span> word</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__len__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">len</span>(<span class="variable language_">self</span>.words)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__repr__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="string">f&#x27;Sentence(<span class="subst">&#123;reprlib.<span class="built_in">repr</span>(self.sentence)&#125;</span>)&#x27;</span></span><br></pre></td></tr></table></figure>

<p>这个版本的实现里，使用<code>__iter__</code>代替了<code>__getitem__</code>，因此更“地道”的可迭代实现。</p>
<h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>任何含有<code>yield</code>关键字的函数都是<strong>生成器函数（generator function）</strong>，生成器函数的返回值是生成器对象。</p>
<h1 id="序列类型3：更懒一点"><a href="#序列类型3：更懒一点" class="headerlink" title="序列类型3：更懒一点"></a>序列类型3：更懒一点</h1><p>在前两个版本的实现中，<code>__init__</code>会立即计算出所有的words，不管后面会不会用到，为了性能与占用内存计，我们希望类型能“更懒一点”。</p>
<p>使用Python 3时，每当你考虑“有否更懒的方式”，答案一般是肯定的。这里可以使用<code>re.finditer()</code>：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Sentence</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, sentence</span>):</span><br><span class="line">        <span class="variable language_">self</span>.sentence = sentence</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__iter__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">for</span> <span class="keyword">match</span> <span class="keyword">in</span> RE_WORD.finditer(<span class="variable language_">self</span>.sentence):</span><br><span class="line">            <span class="keyword">yield</span> <span class="keyword">match</span>.group()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__repr__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="string">f&#x27;Sentence(<span class="subst">&#123;reprlib.<span class="built_in">repr</span>(self.sentence)&#125;</span>)&#x27;</span></span><br></pre></td></tr></table></figure>

<p>修改之后，原来的<code>self.words</code>不再需要。不过，这还不是最短的实现。</p>
<h1 id="序列类型4：生成器表达式"><a href="#序列类型4：生成器表达式" class="headerlink" title="序列类型4：生成器表达式"></a>序列类型4：生成器表达式</h1><p>生成器表达式可以理解为惰性版的列表推导：如果列表推导是一个列表工厂，那么生成器表达式就是一个生成器工厂。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Sentence</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, sentence</span>):</span><br><span class="line">        <span class="variable language_">self</span>.sentence = sentence</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__iter__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">match</span>.group() <span class="keyword">for</span> <span class="keyword">match</span> <span class="keyword">in</span> RE_WORD.finditer(<span class="variable language_">self</span>.sentence))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__repr__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="string">f&#x27;Sentence(<span class="subst">&#123;reprlib.<span class="built_in">repr</span>(self.sentence)&#125;</span>)&#x27;</span></span><br></pre></td></tr></table></figure>

<p>生成器表达式只是语法糖，它们总是可以被替换为生成器函数，只是有时更为方便。</p>
<h1 id="定义自己的range生成器"><a href="#定义自己的range生成器" class="headerlink" title="定义自己的range生成器"></a>定义自己的range生成器</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ArithmeticProgression</span>:</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, begin=<span class="number">0</span>, step=<span class="number">1</span>, end=<span class="literal">None</span></span>):</span><br><span class="line">        <span class="variable language_">self</span>.begin = begin</span><br><span class="line">        <span class="variable language_">self</span>.step = step</span><br><span class="line">        <span class="variable language_">self</span>.end = end</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__iter__</span>(<span class="params">self</span>):</span><br><span class="line">        result = <span class="built_in">type</span>(<span class="variable language_">self</span>.begin+<span class="variable language_">self</span>.step)(<span class="variable language_">self</span>.begin)</span><br><span class="line">        forever = <span class="variable language_">self</span>.end <span class="keyword">is</span> <span class="literal">None</span></span><br><span class="line">        index = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> forever <span class="keyword">or</span> result &lt; <span class="variable language_">self</span>.end:</span><br><span class="line">            <span class="keyword">yield</span> result</span><br><span class="line"></span><br><span class="line">            index += <span class="number">1</span></span><br><span class="line">            result = <span class="variable language_">self</span>.begin + <span class="variable language_">self</span>.step * index</span><br></pre></td></tr></table></figure>

<p>这里的<code>__iter__</code>函数只是返回一个生成器，所以这个类实际上可以简化为生成器函数。</p>
<h1 id="标准库中的生成器函数"><a href="#标准库中的生成器函数" class="headerlink" title="标准库中的生成器函数"></a>标准库中的生成器函数</h1><p>这类函数定义在<code>itertools</code>和<code>functools</code>中，分为以下几类：</p>
<h2 id="Filtering"><a href="#Filtering" class="headerlink" title="Filtering"></a>Filtering</h2><ul>
<li>compress：通过一个iterable对另一个过滤；</li>
<li>dropwhile</li>
<li>filter</li>
<li>filterfalse</li>
<li>islice：对任一iterable实施slice操作</li>
<li>takewhile：</li>
</ul>
<h2 id="Mapping"><a href="#Mapping" class="headerlink" title="Mapping"></a>Mapping</h2><ul>
<li>accumulate</li>
<li>enumerate</li>
<li>map</li>
<li>starmap</li>
</ul>
<h2 id="Merging-Generators"><a href="#Merging-Generators" class="headerlink" title="Merging Generators"></a>Merging Generators</h2><ul>
<li>chain</li>
<li>chain.from_iterable</li>
<li>product</li>
<li>zip</li>
<li>zip_longest</li>
</ul>
<h2 id="Expanding-Generators"><a href="#Expanding-Generators" class="headerlink" title="Expanding Generators"></a>Expanding Generators</h2><ul>
<li>combinations</li>
<li>combinations_with_replacement</li>
<li>count</li>
<li>cycle</li>
<li>permutations</li>
<li>repeat</li>
</ul>
<h2 id="Rearranging-Generators"><a href="#Rearranging-Generators" class="headerlink" title="Rearranging Generators"></a>Rearranging Generators</h2><ul>
<li>groupby</li>
<li>reversed</li>
<li>tee</li>
</ul>
<h1 id="yield-from"><a href="#yield-from" class="headerlink" title="yield from"></a>yield from</h1><p>PS：py3.3引入的新语法。</p>
<h1 id="生成器作为协程"><a href="#生成器作为协程" class="headerlink" title="生成器作为协程"></a>生成器作为协程</h1><p>py2.5引入了协程，协程向生成器对象添加了新的方法——主要是<code>.send()</code>。这一“enhancement”实际上改变了生成器的本质：如此一来，它们变成了协程。David Beazley尝言：</p>
<ul>
<li>生成器产生迭代器（用于迭代）</li>
<li>协程是数据的消费者</li>
<li>不要将两个概念混在一起使用</li>
<li>协程与“迭代”无关</li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://anderscui.github.io/2017/10/24/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0%E5%8F%8A%E5%85%B6%E5%BA%94%E7%94%A8-%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0%E4%B8%AD%E7%9A%84%E7%BA%BF%E6%80%A7%E6%96%B9%E7%A8%8B%E7%BB%84/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Anders Cui">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="mathacker">
      <meta itemprop="description" content="时光中的碎片">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | mathacker">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2017/10/24/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0%E5%8F%8A%E5%85%B6%E5%BA%94%E7%94%A8-%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0%E4%B8%AD%E7%9A%84%E7%BA%BF%E6%80%A7%E6%96%B9%E7%A8%8B%E7%BB%84/" class="post-title-link" itemprop="url">线性代数及其应用-线性代数中的线性方程组</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2017-10-24 00:51:43" itemprop="dateCreated datePublished" datetime="2017-10-24T00:51:43+08:00">2017-10-24</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2025-06-22 07:01:37" itemprop="dateModified" datetime="2025-06-22T07:01:37+08:00">2025-06-22</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>原书链接：<a href="https://book.douban.com/subject/1425950/">线性代数及其应用</a></p>
<h1 id="0-1-前言"><a href="#0-1-前言" class="headerlink" title="0.1 前言"></a>0.1 前言</h1><p>完成微积分的学生学习起来更易接受。</p>
<h2 id="本身特点"><a href="#本身特点" class="headerlink" title="本身特点"></a>本身特点</h2><ul>
<li>提前介绍主要概念</li>
<li>矩阵乘法的现代观点：定义和证明中使用矩阵的“列”，而非“元素”，核心课题是<strong>将矩阵与向量之乘积$Ax$视为关于$A$的列的一个线性组合</strong>。这种现代方法简化了很多论述，并将向量空间和线性系统的研究联系在了一起。</li>
<li>线性变换：贯穿整本书，增强了本书的几何趣味。</li>
<li>特征值和动力系统：特征值来源并应用于离散动力系统和连续动力系统。</li>
<li>正交性和最小二乘法：与普通入门教材相比，本书对这些主题的讨论更为全面。</li>
</ul>
<h1 id="0-2-给学生的注释"><a href="#0-2-给学生的注释" class="headerlink" title="0.2 给学生的注释"></a>0.2 给学生的注释</h1><p>独立完成尽可能多的习题，过早查看答案，会误以为已经理解了尚未理解的概念。</p>
<p><strong>线性代数是一种语言</strong>，用学习外语的方法<strong>每天学习这种语言</strong>。</p>
<h2 id="数值计算的注解"><a href="#数值计算的注解" class="headerlink" title="数值计算的注解"></a>数值计算的注解</h2><p>关注一下这部分内容，因为现实中的应用通常会涉及一定误差下的计算，这部分可帮助你理解计算中潜在的困难。</p>
<h2 id="Study-Guide"><a href="#Study-Guide" class="headerlink" title="Study Guide"></a>Study Guide</h2><p>善用之。</p>
<h1 id="第一章-线性代数中的线性方程组"><a href="#第一章-线性代数中的线性方程组" class="headerlink" title="第一章 线性代数中的线性方程组"></a>第一章 线性代数中的线性方程组</h1><p>1949年夏末，哈佛大学教授列昂惕夫（Leontief）使用当时最大的计算机之一Mark II计算包含500个未知数的500个方程的方程组。由于运算量“过大”，他只好将问题简化为包含42个未知数的42个方程的方程组。他后来获得了诺贝尔经济学奖，他在哈佛的工作标志着<strong>应用计算机分析大规模数学模型的开始</strong>。</p>
<p>线性代数在科学的各个领域有极为广泛的应用。</p>
<p><strong>线性方程组是线性代数的核心</strong>，本章以它来引入线性代数的许多重要概念。先介绍求解线性方程组的一个系统方法；再说明线性方程组等价于一个向量方程与矩阵方程，其后引出线性组合、线性表示与线性变换等概念。</p>
<h2 id="1-1-线性方程组"><a href="#1-1-线性方程组" class="headerlink" title="1.1 线性方程组"></a>1.1 线性方程组</h2><p>本章先是讨论求解线性方程组的一个系统方法。早在初中数学里，我们就学过了线性方程组的求解方法，当时实际上已经提到了解法的一般过程，核心部分是<strong>消元</strong>，因为只有消元才能将方程转化为可直接求解的一元方程。本章讨论的系统方法也是循着这一思路。</p>
<p>包含未知数$x_1, x_2, \cdots, x_n$的一个<strong>线性方程</strong>是形如</p>
<p>$$a_1x_1 + a_2x_2 + \cdots + a_nx_n &#x3D; b$$</p>
<p>的方程，其中$b$与诸系数是实数或复数，通常为已知数。</p>
<p>而<strong>线性方程组</strong>是由一个或几个包含相同变量$x_1, x_2, \cdots, x_n$的线性方程组成的。</p>
<p>方程组的一个<strong>解</strong>是一组数$(s_1, s_2, \cdots, s_n)$，解满足方程组的每一个方程。方程组所有可能的解的集合称为其<strong>解集</strong>。两个方程组称为等价的，若它们有相同的解集。</p>
<p>最简单的线性方程是<strong>二元一次方程</strong>，在几何上它对应于一条直线，它的解与直线上的点一一对应。而两个二元一次方程构成方程组的解集，即对应于两条直线的交点。两条直线可能会相交、平行或重合，这意味着该类方程组的解集也有三种情形：</p>
<ol>
<li>唯一解</li>
<li>无穷多解</li>
<li>无解</li>
</ol>
<p>我们说一个线性方程组是<strong>相容的</strong>，若它有一个或无穷多个解（即有解）；否则称它为<strong>不相容的</strong>（即无解）。</p>
<h3 id="1-1-1-矩阵记号"><a href="#1-1-1-矩阵记号" class="headerlink" title="1.1.1 矩阵记号"></a>1.1.1 矩阵记号</h3><p>给定一个线性方程组，可以想见，该方程组解集的情况取决于系数和等式右端的常数，与未知数的具体记号无关，所以可以用一个<strong>矩阵</strong>（矩形阵列）来表示方程组，如</p>
<p>$$\begin{split}<br>	x_1 - 2x_2 + x_3 &#x3D; 0<br> 	\<br> 	2x_2 - 8x_3 &#x3D; 8<br> 	\<br> 	-4x_1 + 5x_2 + 9x_3 &#x3D; -9<br>  \end{split}$$</p>
<p>矩阵</p>
<p>$$\begin{bmatrix}<br>      1 &amp; -2 &amp; 1  \[0.3em]<br>      0 &amp; 2  &amp; -8 \[0.3em]<br>      -4 &amp; 5 &amp; 9<br>  \end{bmatrix}$$</p>
<p>称为方程组的<strong>系数矩阵</strong>，而加上方程组右端常数列的</p>
<p>$$\begin{bmatrix}<br>      1 &amp; -2 &amp; 1 &amp; 0 \[0.3em]<br>      0 &amp; 2  &amp; -8 &amp; 8 \[0.3em]<br>      -4 &amp; 5 &amp; 9 &amp; 9<br>  \end{bmatrix}$$</p>
<p>称为其<strong>增广矩阵</strong>。</p>
<p>矩阵的定义引出其<strong>维数</strong>的概念，表示其行列数。上述增广矩阵的维数是3行4列，一般矩阵称$m \times n$矩阵。</p>
<h3 id="1-1-2-线性方程组的解法"><a href="#1-1-2-线性方程组的解法" class="headerlink" title="1.1.2 线性方程组的解法"></a>1.1.2 线性方程组的解法</h3><p>基本思路是<strong>把方程组用一个更容易的等价方程组代替</strong>，类似于我们熟悉的<strong>消元法</strong>。</p>
<p>化简方程组有三种<strong>基本变换</strong>（即<strong>行初等变换</strong>）：</p>
<ul>
<li>倍加</li>
<li>对换</li>
<li>倍乘（一行的所以元素乘以同一个非零数）</li>
</ul>
<p>容易证明，一个方程组的增广矩阵经过若干次行初等变换后，新方程组与原方程组解集相同。而且，这些<strong>行变换是可逆的</strong>。</p>
<h3 id="1-1-3-存在与唯一性问题"><a href="#1-1-3-存在与唯一性问题" class="headerlink" title="1.1.3 存在与唯一性问题"></a>1.1.3 存在与唯一性问题</h3><p>前面提及，线性方程组的解集有三种可能，可归为如下两个基本问题：</p>
<ol>
<li>方程组是否相容，即它是否有解？</li>
<li>若它有解，解是否唯一？</li>
</ol>
<p>通过行变换法，我们可以借助化简了的增广矩阵判断出方程组是否有解，进一步得出其解是否唯一。</p>
<h3 id="1-1-4-解方程组与数值计算"><a href="#1-1-4-解方程组与数值计算" class="headerlink" title="1.1.4 解方程组与数值计算"></a>1.1.4 解方程组与数值计算</h3><p>计算机中的浮点数表示难免出现舍入误差，这种不精确性有时需要引起注意。</p>
<h2 id="1-2-行化简与阶梯型矩阵"><a href="#1-2-行化简与阶梯型矩阵" class="headerlink" title="1.2 行化简与阶梯型矩阵"></a>1.2 行化简与阶梯型矩阵</h2><p>将1.1中的方法精确化后，可以得到<strong>行化简算法</strong>，可以解任意线性方程组，而且容易编程实现。这样就可以解决1.1中提出的存在与唯一性问题。该算法适用于任意矩阵。</p>
<p>矩阵中的<strong>非零行&#x2F;列</strong>指矩阵中至少包含一个非零元素的行&#x2F;列，非零行的<strong>先导元素</strong>指该行中最左边的非零元素。由此引出两类矩阵：</p>
<p><strong>定义</strong>：一个矩阵称为<strong>阶梯形</strong>（或<strong>行阶梯形</strong>），若它有以下三个性质：</p>
<ol>
<li>每一非零行在零行之上；</li>
<li>每一行的先导元素所在的列位于前一行先导元素的右面；</li>
<li>某一先导元素所在列下方元素都是零。</li>
</ol>
<p>若一个阶梯形矩阵还满足以下性质，则称它为<strong>简化阶梯形</strong>：</p>
<ol start="4">
<li>每一非零行的先导元素是1；</li>
<li>每一先导元素1是该元素所在列的唯一非零元素。</li>
</ol>
<p>若一个矩阵具有阶梯形（简化阶梯形），它就称为阶梯形（简化阶梯形）矩阵。一个矩阵可以行化简为阶梯形矩阵，不同的方法可能得到不同的阶梯形，但一个矩阵只能化为唯一的简化阶梯形矩阵。</p>
<p><strong>定理1：每个矩阵行等价于唯一的简化阶梯形矩阵</strong>。</p>
<h3 id="1-2-1-主元位置"><a href="#1-2-1-主元位置" class="headerlink" title="1.2.1 主元位置"></a>1.2.1 主元位置</h3><p>矩阵化为阶梯形后，进一步化为简化阶梯形时，先导元素的位置并不改变，而简化阶梯形是唯一的，故<strong>一个矩阵的所有阶梯形的先导元素在相同的位置上</strong>。这些先导元素对应于简化阶梯形的先导1。</p>
<p>定义：矩阵中的<strong>主元位置</strong>是对应于其阶梯形中先导元素的位置，含有主元位置的列称为<strong>主元列</strong>。</p>
<p>将矩阵化为阶梯形就可以确定出主元位置，该过程可手工计算完成，由此可抽象出一个通用的<strong>行化简算法</strong>。</p>
<h3 id="1-2-2-行化简算法"><a href="#1-2-2-行化简算法" class="headerlink" title="1.2.2 行化简算法"></a>1.2.2 行化简算法</h3><p>该算法分为5步，1-4步化矩阵为阶梯形，自左至右，称为<strong>向前步骤</strong>，第5步化阶梯形为简化阶梯形，自右至左，称为<strong>向后步骤</strong>。</p>
<p><strong>数值计算的注解</strong>：第2步选择主元时，一般选择一列中绝对值最大的元素作为主元，此方法称为<strong>部分主元法</strong>，可减少舍入误差。</p>
<h3 id="1-2-3-线性方程组的解"><a href="#1-2-3-线性方程组的解" class="headerlink" title="1.2.3 线性方程组的解"></a>1.2.3 线性方程组的解</h3><p>行化简算法应用于方程组的增广矩阵时，可以得出线性方程组解集的一种显式方法。比如，一个方程组化简之后如下：</p>
<p>$$\begin{split}<br>	x_1 - 5x_3 &#x3D; 1<br> 	\<br> 	x_2 + x_3 &#x3D; 4<br> 	\<br> 	0 &#x3D; 0<br>  \end{split}$$</p>
<p>其相应的增广矩阵也得到了化简，对应于主元列的变量$x_1$和$x_2$称为<strong>基本变量</strong>，$x_3$则称为<strong>自由变量</strong>。</p>
<p>若方程组是相容的，其解集可显式表示出来。如果有自由变量，则用其表示基本变量。由于件化阶梯形中，每个基本变量仅包含在一行（一个方程）中，这是容易表示的。上面的方程组解集可表示为：</p>
<p>$$\begin{cases}<br>    x_1 &#x3D; 1 + 5x_3 \<br>    x_2 &#x3D; 4 - x_3  \<br>    x_3是自由变量<br>  \end{cases}<br>$$</p>
<p>所谓自由变量是指它可以取任意的值。自由变量的值确定之后，基本变量的值也随之确定下来。这种解集表示称为<strong>通解</strong>，因为它给出了方程组所有解的显式表示。此种表示亦称为解集的<strong>参数表示</strong>，其中自由变量作为参数。</p>
<p>若方程组是相容的，且具有自由变量，那么其<strong>解集具有多种参数表示</strong>，一般约定为使用自由变量作为参数来表示。</p>
<h3 id="1-2-4-回代"><a href="#1-2-4-回代" class="headerlink" title="1.2.4 回代"></a>1.2.4 回代</h3><p>计算机程序在解线性方程组时，通常使用<strong>回代法</strong>求解，即在阶梯形基础上回代，而非求出简化阶梯形后再求解。一个浮算（flop）就是两个浮点数的一次运算，一般地行化简算法的向前步骤比向后步骤需要更多运算。使用Matlab的<code>flops</code>可以计算某次计算中所需要的浮算次数。</p>
<p>手工计算时求出简化阶梯形更不易出错。</p>
<h3 id="1-2-5-存在与唯一性问题"><a href="#1-2-5-存在与唯一性问题" class="headerlink" title="1.2.5 存在与唯一性问题"></a>1.2.5 存在与唯一性问题</h3><p>虽然非简化阶梯形不能直接解出线性方程组，但已足以回答关于方程组的两个基本问题，也就是如下的定理。</p>
<p><strong>定理2</strong>：存在与唯一性定理</p>
<p>线性方程组相容的充要条件是增广矩阵的最右列不是主元列。若方程组相容，当其没有自由变量，有唯一解；否则有无穷多解。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://anderscui.github.io/2017/10/05/%E6%95%B0%E5%AD%A6%E5%88%86%E6%9E%90%E5%85%AB%E8%AE%B2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Anders Cui">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="mathacker">
      <meta itemprop="description" content="时光中的碎片">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | mathacker">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2017/10/05/%E6%95%B0%E5%AD%A6%E5%88%86%E6%9E%90%E5%85%AB%E8%AE%B2/" class="post-title-link" itemprop="url">《数学分析八讲》笔记</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2017-10-05 02:28:28" itemprop="dateCreated datePublished" datetime="2017-10-05T02:28:28+08:00">2017-10-05</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2025-06-22 07:01:37" itemprop="dateModified" datetime="2025-06-22T07:01:37+08:00">2025-06-22</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p><a href="https://book.douban.com/subject/4825571/">数学分析八讲 原书链接</a>，作者辛钦。</p>
<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>非数学专业的工程师、经济学家等，一般会先行学习较为简单的微积分，到了某个时候发现需要更为牢固的数学基础。如果找一本《微积分学教程》来看，事实证明效果不佳。学习者要么无法安排足够的时间去学习，要么还没有足够好的数学基础，无法从研究中区分出哪些是原则的内容，哪些是较为微末的细节。</p>
<p>要满足这类学生的需求，所需其实有限。我的秘诀是：从一开始就拒绝充分详细地讲授哪怕只是阐述本课程牟一章的想法，而只限于讲授那些<strong>具有原则性的内容</strong>。我讲的更多地是关于目的和趋势、问题和方法、基本的分析概念之间的以及它们与应用之间的<strong>关系</strong>，而不是个别的定理与证明。但在有着主导作用和原则意义的概念或方法上，我则不吝时间，力求用各种手段，通过各种表述和直观形象等，尽可能明白而有效地把这些基本内容教给我的学生。有了这个基础，<strong>他们每一个人在需要更深入地研究数学分析的某一章节时，就能够独立地找到他所需的材料，然后进行研究，也就是说，可以自立地区分主要和次要、本质和非本质</strong>。</p>
<h1 id="第一讲-连续统"><a href="#第一讲-连续统" class="headerlink" title="第一讲 连续统"></a>第一讲 连续统</h1><h2 id="为什么数学分析必须从研究连续统开始？"><a href="#为什么数学分析必须从研究连续统开始？" class="headerlink" title="为什么数学分析必须从研究连续统开始？"></a>为什么数学分析必须从研究连续统开始？</h2><blockquote>
<p>如果对于变量$x$的每一个值，变量$y$都有唯一确定的值与之对应，那么变量$y$称为变量$x$的函数。</p>
</blockquote>
<p>借助于这句话，我们可以定义<strong>最重要的、最首要的数学分析概念</strong>——<strong>函数关系</strong>。在此概念中，已经奠定了借助数学工具来把握自然现象和技术过程的完整思想的萌芽。由于其重要性，我们需要给该定义完全的明确性，其中的每一个字都不应有引起一点怀疑的阴影。</p>
<p>变量$x$的每一个值，构成了函数的<strong>定义域</strong>（$x$称为<strong>自变量</strong>，$y$称为<strong>因变量</strong>）。而”值“具体是什么？它应该是数，那么定义域应当是一个<strong>数集</strong>。这里先排除掉虚数（其中的分析涉及<strong>复变函数</strong>），假设自变量与因变量皆为<strong>实数</strong>。</p>
<p>函数的定义域既取决于该函数的性质，也取决于特定的问题。前者给出自然定义域，后者给出更为特殊的定义域。</p>
<p>数学分析中，最常见的$x$集合是<strong>区间</strong>，区间或是有界的，或是无界的（半直线或直线）。无论如何，对于数学分析中的函数而言，最根本的数集是<strong>实数集</strong>。这个集合在数学中称为<strong>连续统</strong>（或线性连续统）。因其根本，所有认真而科学地编写的数学分析教程中，连续统都是第一个研究对象。</p>
<h2 id="为什么没有建立完整的实数理论是不能研究连续统的？"><a href="#为什么没有建立完整的实数理论是不能研究连续统的？" class="headerlink" title="为什么没有建立完整的实数理论是不能研究连续统的？"></a>为什么没有建立完整的实数理论是不能研究连续统的？</h2><p>那么连续统是什么样的？存在什么样的实数？如何我们才能相信已经了解了所有实数？</p>
<p>在所有的数中，我们最先接触到有理数，它可以表示可公度线段的长度，不管是整数值还是分数值，它是相当直观的。但有的线段长度无法用有理数表示，最经典的就是$\sqrt{2}$。这样，我们需要承认<strong>非有理数</strong>的存在，或更直接的<strong>无理数</strong>，如果不承认，某些线段的长度就无法表示。</p>
<p>有了无理数，就是引入了新数，新数需要确定出它与旧数的关系，至少有二：它与一个有理数的大小关系；它与有理数的运算表示，并且运算结果会产生其它新数，如$1 + \sqrt{2}$。</p>
<p>$\sqrt{2}$之后，不可避免地要考虑所有形如$r^{1&#x2F;n}$的数，其中$r$是任意正有理数，$n$是$\geq 2$的整数。</p>
<p>继续这个过程，我们称形如$P(x) &#x3D; 0$的方程的所有实根为<strong>代数数</strong>，其中的$P(x)$为带整系数的任意多项式，并把所有代数数引入到我们的新数集。特别地，任何有理数$r &#x3D; \frac{p}{q}$可作为方程$qx - p &#x3D; 0$的根包含进代数数的集合中。</p>
<p>代数数是我们数集的一个扩展，我们可以给出法则使其可以排序，以及进行代数运算。看起来已经是一个相当不错的扩展了。但是<strong>在分析之中，仅限于代数数是不够的</strong>。</p>
<h3 id="代数数与极限"><a href="#代数数与极限" class="headerlink" title="代数数与极限"></a>代数数与极限</h3><p>数学分析的第一步就要对初等代数运算添加基本且重要的分析运算——<strong>极限过程</strong>。极限不止是概念上的，还有具体而现实的意义，而且还要支持代数运算和分析运算。</p>
<p>如果任何代数数序列的极限都是代数数，那么我们是可以说，代数数集合就是<strong>连续统</strong>（关键在于，它能满足于我们的需要）。我们取单位圆，并且作出其内接正多边形，无限增加其边数，那么这些周长都可以用代数数表示。这个代数数序列的极限为圆周长（即$2\pi$）。这个极限必须承认是存在的，否则就等于是否定了圆周率。</p>
<p>另一方面，则可以证明这个极限不是代数数。这也说明，数学分析中仅考虑代数数是不够的。事实上，$\pi$这样的数称为<strong>超越数</strong>。我们的数集需要包含代数数与超越数。另一个重要的超越数是$e$。</p>
<p>那么，对于超越数我们能了解什么？现在只知道某些特殊的极限值是超越数，如$\pi$和$e$。是否可以说，我们的连续统包括所有的代数数，加上”根据需要，再添加某些特别的超越数“呢？这种定义的问题是：</p>
<ul>
<li>该集合不是一个确定性的集合，随时有可能需要添加新数</li>
<li>该定义不像有理数和代数数那样具有一致的定义，也不够优雅</li>
<li>该定义无法保证，对于新引入的数，可以一致地满足代数运算与极限运算（如代数数那样），在某些情况下，还需要引入其它数，这说明连续统还没有包含所有的实数</li>
</ul>
<p>现在可以看到，对于连续统，我们不能仅限于”按照需要“引入几个新数，而是要给出<strong>建立实数的一般性理论</strong>，该理论适用于所有的实数。</p>
<h2 id="无理数的构造"><a href="#无理数的构造" class="headerlink" title="无理数的构造"></a>无理数的构造</h2><p>存在几种不同的连续统理论，它们在处理各自问题时的<strong>思路是完全一样的</strong>。在论证时，不需要囿于某一特定的理论，可以组合或交替使用。</p>
<p><strong>所有这些理论都把有理数作为最初的数据</strong>，然后<strong>用统一的构造原则得到所有实数的集合</strong>。各种理论都基于统一思想，即：<strong>在构造新数时，基本解析极限过程起首要、主导的作用</strong>，所遇到的种种方法都可以归结为它。例如，$\sqrt{2}$的值可视为一个经过适当选择而得的有理数序列的极限。</p>
<p>构造连续统的三种方法是：</p>
<ul>
<li>戴德金分割方法</li>
<li>康托尔的基本列方法</li>
<li>魏尔斯特拉斯从十进小数表示出发的方法</li>
</ul>
<p>本书采用戴德金分割法，因其在各种教材中被广泛的采纳。</p>
<p>在引入无理数之前，我们再仔细地观察以$R$（一般用$R$表示实数）表示的有理数集。首先是它的<strong>稠密性</strong>，即任何两个有理数$r_1$和$r_2$之间总可以找到第三个有理数，最简单的例子是两者的平均数。作为推论，我们可以得出，在$r_1$和$r_2$之间始终存在有理数的无穷集合。</p>
<p>现在，考察定义$\sqrt{2}$时的情况，该数不在有理数中。那么，如果<strong>仅考虑正有理数</strong>的话，任意给定有理数$r$，要么$r^2 &lt; 2$，要么$r^2 &gt; 2$。据此，正有理数可分为两类：A类，其中的数$r_1$满足$r_1^2 &lt; 2$，B类，其中的数$r_2$满足$r_2^2 &lt; 2$，因$r_1, r_2$皆为正数，故有$r_1 &lt; r_2$。这说明<strong>A类中的每个数都小于B类中的每个数</strong>。然后我们把零和所有负数归到A类，那么上述结论不变。这时我们得到有理数集的一个<strong>分割</strong>。</p>
<blockquote>
<p>若将$R$分为两个非空的类（A，B），且A类中的每一个数都小于B类，就称之为<strong>分割</strong>。</p>
</blockquote>
<p>我们可以用更简单的方法得到分割。如把所有小于等于5的数归为A类，大于5的归为B类。如果把有理数对应到数轴上的点，那么这种分割是非常直观的。</p>
<p>现在我们有两个分割的例子，即由$\sqrt{2}$和$5$构造的。它们只是有位置的差别，还是有本质的区别？对于我们构造实数这一目的来说，它们是很不一样的。原因是，第二个分割中，$5$将有理数分割为两类，所有其它的数，或大于或小于它，而它自身也属于有理数，这种数称为<strong>分割的界限</strong>；而第一个分割不存在这样的界限。</p>
<p>PS：界限，是指其本身是有理数，同时小于它的有理数属于一类，大于大的有理数属于另一类。是故$5$是界限，而$\sqrt{2}$所定义的分割没有界限（证明见P6）。</p>
<p>这样有理数集$R$的所有分割分为两种类型：有界限的和无界限的。此外，界限还有其它性质：</p>
<ul>
<li>一个分割不可能有两个界限</li>
<li>若界限存在，则其要么是$A$类最大数，要么是$B$类最小数</li>
<li>每一个有理数$r_0$都是两个不同分割的界限，其一的$A$类是$r \leq r_0$，其二的$A$类是$r &lt; r_0$</li>
</ul>
<p>由$\sqrt{2}$的例子可以看出，这样的数是存在的（单位正方形的对角线长度），而且如果不添加这样的数，那么数集就没有其<strong>连续性</strong>和<strong>致密性</strong>。因此，我们可考虑依据<strong>分割的界限</strong>来定义新数，即<strong>无理数</strong>。</p>
<p>对于有理数集$R$的每一个没有界限的分割，我们都定义一个新的无理数与之对应，并定义此无理数即分割的界限。根据这个统一的原则，我们就确定了整个无理数的集合。连同已知的有理数集，它们构成了所有实数的几何，即<strong>连续统</strong>。</p>
<h2 id="连续统理论"><a href="#连续统理论" class="headerlink" title="连续统理论"></a>连续统理论</h2><p>上面由分割，可以构造新的无理数，或者说所有的无理数，但这一原则只是连续统理论的开始，还有大量其它工作要做：</p>
<ul>
<li>对连续统<strong>排序</strong>，确定两个实数的大小关系</li>
<li>对实数定义运算，比如$1 + \sqrt{2}$的值是什么</li>
<li>新运算具有有理数域中我们所熟知的全部性质，如加法的交换律</li>
<li>确认我们定义的连续统确实已经适应了所有实际和直观表示之需要</li>
</ul>
<p>以下将讨论实数的各个性质，须知有理数和无理数都对应到两个分割，有理数是分割的界限且为最大&#x2F;小数，无理数则不是界限，其分类亦无最大&#x2F;小数。</p>
<h3 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h3><p>利用上面提及的实数与分割关系可以证得（详见P8），两个实数各自决定的分割也决定了它们之间的大小关系。</p>
<h3 id="运算"><a href="#运算" class="headerlink" title="运算"></a>运算</h3><p>在P8-9，书中以实数加法运算为例说明了如何为连续统添加运算，以及这些运算仍然满足旧有的运算律。</p>
<h3 id="连续统的连续性"><a href="#连续统的连续性" class="headerlink" title="连续统的连续性"></a>连续统的连续性</h3><p>至此所谈及的分割都是对于有理数集的分割，这些分割有的是不存在界限的，如$\sqrt{2}$，看起来就像是有理数之间夹杂着一些不属于有理数的数，那么以数轴的角度看，有理数集是<strong>不连续的</strong>。这种不连续性也是我们扩展有理数集的原因。</p>
<p>引入无理数并且定义了实数的排序后，也可以定义连续统的分割。如果每一个连续统的分割都有一个实数作为界限（证明见P10），那么我们可以说连续统本身是连续的，这样就弥补了有理数集的不足，而数学分析的讨论就可以继续下去了。</p>
<h2 id="基本引理"><a href="#基本引理" class="headerlink" title="基本引理"></a>基本引理</h2><p>以分割建立起来的连续统为我们带来了数学分析的逻辑基础。理论上来说，接下来的所有研究都可以直接回溯到分割的定义去解决问题，但实际上很多时候，构造分割是繁琐的过程。数学家们引入了几个辅助命题（引理），这些引理在很多情况下比分割更为方便，一旦证明了这些引理，就可以把它们和分割定义一起作为后续研究的工具。</p>
<h3 id="关于单调序列的引理"><a href="#关于单调序列的引理" class="headerlink" title="关于单调序列的引理"></a>关于单调序列的引理</h3><p><strong>引理1</strong>：任何单调有界序列都有极限。</p>
<h1 id="第二讲-极限"><a href="#第二讲-极限" class="headerlink" title="第二讲 极限"></a>第二讲 极限</h1>
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://anderscui.github.io/2017/10/04/%E6%8E%A7%E5%88%B6%E5%8A%9B%E5%B9%BB%E8%B1%A1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Anders Cui">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="mathacker">
      <meta itemprop="description" content="时光中的碎片">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | mathacker">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2017/10/04/%E6%8E%A7%E5%88%B6%E5%8A%9B%E5%B9%BB%E8%B1%A1/" class="post-title-link" itemprop="url">控制力幻象</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2017-10-04 00:29:55" itemprop="dateCreated datePublished" datetime="2017-10-04T00:29:55+08:00">2017-10-04</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2025-06-22 07:01:37" itemprop="dateModified" datetime="2025-06-22T07:01:37+08:00">2025-06-22</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>初听，“普通话”令人震惊。</p>
<h1 id="1、导语：跟你的焦虑和解"><a href="#1、导语：跟你的焦虑和解" class="headerlink" title="1、导语：跟你的焦虑和解"></a>1、导语：跟你的焦虑和解</h1><p>焦虑，带着我们过去生活的匮乏，也带着对未来的担心和希望。焦虑的本质就是一种失控感。担心某些东西不在掌控范围内。担心上帝或命运不会善待我们，以至于忘了我们本能够掌控一些东西。</p>
<p>即使在二战集中营这样的环境，我们依然能作出选择。那么理论上，我们的生活中也可以做出不同的选择。</p>
<p>焦虑源于失控感，而失控感源于我们总是试图去控制那些我们控制不了的东西，却不愿对可控者承担起自己的责任。</p>
<p>控制力幻象：我们可以控制很多东西。认清现实后，又不甘心只能控制这么一点，看不到这一点的丰富。</p>
<p>不同的心理咨询的流派都在帮助我们重新建立控制感。</p>
<p>生活是一个修行的道场。</p>
<h1 id="2、乐观的人反而会更焦虑？寻求控制感"><a href="#2、乐观的人反而会更焦虑？寻求控制感" class="headerlink" title="2、乐观的人反而会更焦虑？寻求控制感"></a>2、乐观的人反而会更焦虑？寻求控制感</h1><p>我们有烦恼，是因为我们总妄想去控制那些我们控制不了的东西，却不愿对我们能够控制的东西担负起责任。</p>
<p>控制是人的基本需要。从婴儿时期，人就想控制这个世界了。</p>
<p>控制感是<strong>安全感</strong>的来源。从某种程度上说，人的心智成熟，就是从认为很多事我能控制到发现很多事我不能控制。</p>
<p>精神分析-全能自恋：婴儿觉得自己是无所不能的。喂奶；哭，安抚。逐渐发现，这世界不是围绕着我转的。</p>
<p>夸大我们控制世界的能力。控制别人的评价；如果我当时做对了，某事就如何如何。</p>
<p>天生的乐观派：我做得好，应当得到好评；每个人都应当有美满的原生家庭；愧疚于拖延，则认为本能够长时间保持投入与专注。真相是，这个世界本来就是不完美的。</p>
<p>当现实与想象不符时，我们就会焦虑、沮丧或愤怒。从乐观到悲观。从而不愿去控制那些我们能控制的东西，因为它看起来太微不足道。</p>
<p>逃避责任：比如请出拖延症这个”对象“，你看，因为拖延症我才这样的。事实上，可控者远比我们想象地多，把握和享受这些使我们安全感的来源。它需要换一个看待问题的角度。</p>
<p>当我们说，道理我都懂的时候，就是还没懂的时候。将其置于一个遥远的与己无关的位置，而不愿去践行这个道理。但这是我们可以控制的。</p>
<p>问自己两个问题：</p>
<p>这是我能控制的吗？如果不是，那我能控制什么？</p>
<p>行为模式四个层次：生理、感受、思维和行动。生理反应和情绪感受很难直接控制。思维方式和行动较易进行。</p>
<p>焦虑时很难直接停下，但可以有行动：公园散步，见朋友。如此以思维和行动反过来影响了生理与感受。</p>
<p>上帝，请赐予我勇气，让我改变能够改变的事情；请赐予我胸怀，让我接受不能改变的事情；请赐予我智慧，让我分辨这两者。</p>
<p>尽人事，听天命。</p>
<p>以为可控者之背后，有我们不可控的东西，承认之让人痛苦，但也让我们解脱；以为不可控者之背后，也有我们可控者。这种智慧是帮我们走出焦虑的良方。这种智慧是什么？</p>
<h1 id="3、如何拒绝别人不合理的请求？课题分离法"><a href="#3、如何拒绝别人不合理的请求？课题分离法" class="headerlink" title="3、如何拒绝别人不合理的请求？课题分离法"></a>3、如何拒绝别人不合理的请求？课题分离法</h1><p>关系是影响个体幸福感的最重要因素。</p>
<p>个体心理学家阿德勒：人际关系的烦恼是一切烦恼的根源。人际关系中，什么是可控的，什么是不可控的？</p>
<p>老好人：担心别人恶评；担心他人找不到其它帮忙者。事实上，他人评价不可控，不可剥夺，而且自己行事准则亦不能因他人而定。另一方面，夸大了自己的作用。最极端者，你也不能拯救一个人。</p>
<p>拒绝为何很难？混淆了可控与不可控两者。控制他人之评价；施加自己之影响。（看起来，不是他人需要自己，倒像是自己需要帮助别人，你知道，这会很感人）</p>
<p>各人皆有界，只须做力所能及欲及之事。如果多次欲拒绝而不得，盖其为超出自己界限之信号。</p>
<p>阿德勒：课题分离。区分什么是你的事情，什么是我的事情。我负责把我的事情做好，你也需要如此。</p>
<p>这是谁的事情？判断标准是，谁为结果负责。例：母催女结婚。则女儿反感，又担心不结婚导致母亲不高兴。分离之，则女儿只婚事有其自己承担，母亲不能插手；母亲之高兴由其自己负责，与女儿是否结婚无关，女儿亦无需负责。</p>
<p>拒绝困难：把别人的问题当成了自己的问题。</p>
<p>另一问题，是否显得冷漠？如父亲对儿子之关心。则问题是，如果</p>
<p>爱是，你可以对一个人好或不好时，选择了好，心甘情愿的。课题分离的目的不是分离，而是从人际关系的困扰中解脱出来，回归我们的本心。所谓本心，即自愿地做事。去助人，不是担心评价，或希望感激，而是同情与爱耳。</p>
<p>担心被拒绝：不仅是此行为，亦有背后关系之含义。他是否认为不重要，不在意我？表达需求很难，也是因为背后被评价的恐惧。我们不能控制别人满足自己要求，但我们能控制自己表达需要之需要。</p>
<p>彼得·德鲁克：不为任何人做事，为上帝做事。</p>
<h1 id="4、亲密关系中为什么总想控制对方？排序思维"><a href="#4、亲密关系中为什么总想控制对方？排序思维" class="headerlink" title="4、亲密关系中为什么总想控制对方？排序思维"></a>4、亲密关系中为什么总想控制对方？排序思维</h1><p>亲密关系中，何者不可控，何者可控？</p>
<p>亲密关系的基本动力有两种：权力和爱，相对于思维模式：排序思维和联结思维。</p>
<p>排序思维：把人排出高低贵贱。</p>
<p>控制的企图会极大地伤害两人的关系。愈亲密，愈期待，愈想控制。控制引发斗争，使身处关系中的人痛苦不堪。吃饭、看电影之类的小事儿，所争论者，谁听谁的。这次听了他的，是不是他不尊重我？我是否输了？输赢即典型的排序思维。此种思维者，担心关系中的不平等，害怕被拒绝。<strong>控制代替了亲密，权力代替了爱</strong>。我们以为，控制了别人，爱就会回来。我们可以要求别人做很多事情，却不能控制别人爱。</p>
<p>都是对方的错。尝试改变对方。自己可以做什么改善关系？争论对错，也是排序思维。控制别人，就是控制不可控之事。对方先改，仍然在争高下。放到自己身上，这是自己唯一能控制的事。</p>
<p>放弃控制，才能给对方自主的选择，才能给爱留下空间。</p>
<p>退一步，放弃对对方的控制。把自己的需要和对方的需要分开。</p>
<h1 id="5、自己制定的计划，为什么总是拖延？张力和控制感"><a href="#5、自己制定的计划，为什么总是拖延？张力和控制感" class="headerlink" title="5、自己制定的计划，为什么总是拖延？张力和控制感"></a>5、自己制定的计划，为什么总是拖延？张力和控制感</h1><p>想好好利用时间，制定了<strong>很多目标</strong>。锻炼身体；学英语；读不同领域的书。刷手机、打游戏。何如？</p>
<p>为什么定很多目标？不能定少数几个？</p>
<p>这几个都很重要？看到焦灼的目光，急切地想要改变什么。此时就想要制定各种目标和计划，但这样的计划不是用来实现的，而是用来<strong>缓解焦虑</strong>的，它通过幻想提供一种<strong>虚假的希望</strong>。这样的计划愈是宏大，就愈有“功效”，万一实现了呢？成功学的秘密大概也在于此，他们先是提供焦虑，再献上良方。</p>
<p>那么，这些焦虑的来源是什么？它们是否是恰当的？（焦虑也有恰当一说？）幻想本身无可厚非，但幻想却能减弱行动的力量。制定了很多计划，买了很多书，行动力可能会降下来，因为焦虑已经通过上述行为释放掉了（我毕竟已经做了很多努力了），且有了我已经进步了的<strong>错觉</strong>。</p>
<h2 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h2><p>目标与计划本质不同。目标的本质是张力，如同一张弓。此张力是一种心理上的未完成状态，而且达到目标之前，不会随着行动而消失。</p>
<p>格式塔疗法：未完成事件一直在我们的世界里隐隐作痛，希望去完成它。坏的目标，张力不可持续，做一点，张力少一点。</p>
<p>例：写一本对自己很有意义的书，假设有10章，那么写完第9章，也不会失去动力。如果是坚持写作，那么完成一点，目标的动力就消失一点。</p>
<p>制定一个创造型的目标，如写一本书、完成一幅画、作一首曲子，会比坚持型的目标，如坚持读书、健身更容易。因为创造型的目标，我们心里有一个未完成状态，会保持张力。所以，尝试去<strong>制定一个创造型的目标</strong>。</p>
<p>那么，好的目标是否一定能够完成？不一定，因为是否完成取决于很多因素，如所处时代（互联网的兴起对传统行业的冲击）、运气等等。故有时且需要根据形势调整目标。如果目标是否实现不是我能控制的，那我还能做什么？这就是目标之外的<strong>计划</strong>。</p>
<h2 id="计划"><a href="#计划" class="headerlink" title="计划"></a>计划</h2><p>目标的本质是制造张力，计划的本质是<strong>控制</strong>。做事时的<strong>不可控和不确定的感觉</strong>很折磨人，它容易使人焦虑和拖延。这时需要计划。仔细想想，每个不可控的事情背后，也有其可控的部分。即使努力准备考试，也不确定是否能通过，但去努力却能提高通过的几率。不知道何时有研究灵感，但多读文献，多讨论就更可能产生灵感。</p>
<p>所以，找出可控的部分，做成计划，这就是我们该做的事儿。计划的本质是控制，不是提供虚幻的希望，把注意力放在能做的事情上，让你谦虚、节制、理性。</p>
<p>如果一个计划让你好高骛远，当下却不知道该做什么，只想着做不到的事情，那就不是一个好的计划。好的计划让你沉下心来，脚踏实地。结果不是我们能控制的，却可以说，我已经尽力了。</p>
<h1 id="6、为什么你的人生规划会给你这么大的压力？创造福流"><a href="#6、为什么你的人生规划会给你这么大的压力？创造福流" class="headerlink" title="6、为什么你的人生规划会给你这么大的压力？创造福流"></a>6、为什么你的人生规划会给你这么大的压力？创造福流</h1><p>多隆——阿里的神人 </p>
<p>“就是解决问题嘛”。</p>
<p>状态：不去想我不能控制的事情，只关注我能控制的事情。</p>
<p>基本信条：远大的理想，不能泯与众人。</p>
<p>如果做不好眼前的事情，远大的理想就会成为沉重的负担。</p>
<p>高远的理想下，生活成为一架运行的机器。</p>
<p>只有大纲，没有内容——很乏味。</p>
<p>不希望过程，只希望结果——快快来到。但结果很难控制，恰恰过程才是能控制的，放弃了过程，也就放弃了结果。</p>
<p>没有人能保证生活会如何如何。所以，去做自己能做的事情吧。将自己交付给命运。不是说，只要我努力，上天就一定会给我回报，而是，即使上天不给我回报，我也要去努力投入。</p>
<p>投入不能保证成功，却能带来幸福。漂移不定，比专注投入时更不幸福。Flow，忘我，忘时，沉浸于某事——幸福感的真正来源。条件：需要放下事情以外的<strong>目标的执念</strong>，做好能做的事情，忘我。忘我——到达自我。不要以成功为目标，成功是自己全心投入，置之度外时意外获得的副产品。</p>
<p>投入眼前的事情，把它当做人生规划的手段。</p>
<p>更大的世界：福流可能是向内求得的。</p>
<h1 id="7、目的论和因果论"><a href="#7、目的论和因果论" class="headerlink" title="7、目的论和因果论"></a>7、目的论和因果论</h1><p>找出能够控制的事情，不仅需要常识，还需要换一个角度来看待行为。</p>
<p>焦虑可以“有用”：实现了某种目的。不想面对找工作的挑战，“选择”了焦虑，焦虑给了他一个好的理由为自己开脱，在这种意义上是“有用”的。</p>
<p>虽然有用，缓解了心中的痛苦，但我们也交出了手中的控制权，因为现在找不找工作是由焦虑来控制的了。如果我们说自己“选择”了焦虑，那么是说自己“不想找工作”，焦虑是主动选择的结果，是否出门找工作是由自己来决定的。如此一来，就夺回了控制权，代价是我们得为自己负责了。</p>
<p>因果论：所有发生的事情都有背后的事情，如原生家庭。因果论往往导向过去决定论，而过去是我们没法控制的。</p>
<p>阿德勒的说法目的论：强调行为背后的目的。为了种种目的，我们才有了特定的行为。回避挑战-&gt;制造焦虑。心理问题不是问题-&gt;而是为了满足某个目的而想出来的一种解决方案。</p>
<p>抑郁通过缩小活动空间保护自己；焦虑通过情绪唤醒提醒你有危险接近；自卑通过一系列的退缩行为避免在激烈的竞争中受伤，自卑的痛苦主要来自己不如人，避免了竞争，就避免了不如人情境的发生，同时亦可获得关注与安慰。</p>
<p>初级和次级收益：社会认可的直接收益；情感上的。</p>
<p>阿德勒论故意捣蛋的儿童：获得称赞的需要（人群中的优越感，优越感带来安全感？）；若无称赞，则要表现得与众不同，包括做坏事，以引起关注；若否，开始权力斗争阶段，开始不服任何人；复仇，故意捣乱和破坏；证明自己的无能，回避自己人生发展的课题；作为受害人，谴责他人。</p>
<p>自省：问题行为获得了哪些好处，这些好处反映了自己内心的哪些需求？如果没有这些问题行为，我们还能用哪些方式来满足这些需求？也许这些行为背后也有自己能控制的东西。</p>
<h1 id="8、怎样跟自己的焦虑感对话？"><a href="#8、怎样跟自己的焦虑感对话？" class="headerlink" title="8、怎样跟自己的焦虑感对话？"></a>8、怎样跟自己的焦虑感对话？</h1><p>情绪低落，不想出去活动；生活毫无意义。</p>
<p>抑郁症：标签；确认了，至少有什么是确定了。贴到身上，当作自己的一部分，没法把问题与自我分离。</p>
<p>欲重获控制感，换个角度。</p>
<p>心理咨询技术，来自<strong>叙事疗法</strong>。</p>
<p>黄金棍的故事：控制不住自己-&gt;是自己的问题；棍-&gt;问题是外部的。</p>
<p>外化，分离自己与问题，增加我们的主动性与控制感。找到一个动物、植物或物品，形容问题，找到合适的比喻，这样同时也界定了自己与问题的关系。不要使用斗争关系，易使人紧张，选择轻松温情的。如“黑狗”、“小孩”。</p>
<p>具象：它如何影响我的生活，如何相处，如何找回控制权。</p>
<p>焦虑：小孩；理智：成年人。你听谁的话呢？听听你的问题，它在跟你说什么，你该怎么做呢？</p>
<p>大部分心理咨询的本质就是找回控制感。外化是方法之一。</p>
<h1 id="9、为什么说犯错反而能缓解焦虑？悖论法"><a href="#9、为什么说犯错反而能缓解焦虑？悖论法" class="headerlink" title="9、为什么说犯错反而能缓解焦虑？悖论法"></a>9、为什么说犯错反而能缓解焦虑？悖论法</h1><p>放弃不可控者：顺其自然；为可控者担责：专注精进。</p>
<p>陷入焦虑和恐惧时，很难什么也不做。</p>
<p>标签收集器：什么症状总能找到适合自己者。</p>
<p>有时候，很想控制和改变自己的状态，但这种控制和改变本身也会成为问题。欲睡而不能；欲摆脱焦虑而更为焦虑。但放弃改变之心很难，身处问题，急于改变。</p>
<p>接纳自己：平静之情绪。接纳本身也会成为悖论：要不要接纳那个不接纳自己的自己呢？接纳自己的本质是舍弃，不是追求和获得。舍弃不可控者；舍弃“完美的自己”；舍弃“完美世界的执念”；接纳自己，不是因为它有什么好处，而是缺陷、不完美就是我们生存的事实，如果希望内心平静满足，通常不能成功。</p>
<p>内心平静满足不是目标，而是接纳自己的副产品。</p>
<p>放弃无效的控制，去接近内心的焦虑，是一个巨大的冒险。故悖论中人难以走出悖论。</p>
<p>但悖论也是悖论，不仅是问题，亦可成为方案。治疗自己。</p>
<p>正是恐惧导致了我们害怕的事物出现；过度渴望使我们希望的事情变得不可能。矛盾意向法：越是害怕，就越是在意向中让它发生。比如害怕演讲。制造特别的情境。无论做什么，都能获得控制感，重点是要去做。</p>
<p>犯错说明你在工作，而且可资学习。犯错计划：每周3次。不去过于担心无需担心之事。</p>
<h1 id="10、带着症状去生活：森田疗法"><a href="#10、带着症状去生活：森田疗法" class="headerlink" title="10、带着症状去生活：森田疗法"></a>10、带着症状去生活：森田疗法</h1><p>森田疗法：带着症状生活，为所当为。</p>
<p>手抖：承载着自己的不安和自我怀疑，有其历史，现在表现为手抖。以为心理问题是能够控制的，出现时本能地希望治愈修正它。生活倒映在水里的影子。</p>
<p>身体生病：能够定位；心理问题不能：不是控制心理问题能解决的；无法通过影子来修正原来的问题。</p>
<p>停下生活去治疗它，但治疗的力量却来自于生活本身。</p>
<p>不是艰难的情况下去控制焦虑，而是在偶尔焦虑的情况下去过艰难的生活，让它运转良好。疾病之外的部分是唯一能控制的事情，这就是为所当为。</p>
<p>一方面夸大之；一方面轻视之。</p>
<p>弃疗，去生活。问题以外的生活。生活滚滚向前，以为很重要的事情，变得不那么重要了。</p>
<p>荣格：人生中所有最严重、最重要的事情，基本上都是无解的。问题无法被解决，只会被更大的问题掩盖掉。视野变得更大更宽了，问题也失去了它的紧迫性。</p>
<h1 id="11、为什么说要专注于当下？正念思维"><a href="#11、为什么说要专注于当下？正念思维" class="headerlink" title="11、为什么说要专注于当下？正念思维"></a>11、为什么说要专注于当下？正念思维</h1><p>妄图控制不可控，却不对可控者行使控制权。这里隐含着两种思维模式：</p>
<ul>
<li>远的思维：没有发生之事、抽象的和远的事情；</li>
<li>近的思维：真实的、正在发生的、近的事情</li>
</ul>
<p>远之三特征：</p>
<ul>
<li>过度概括化：不舒服，可理解；但说我总是不受欢迎，就走得太远了；这<strong>一切</strong>有什么用呢？（一切、总是、根本）。此时，无事可控制。</li>
</ul>
<p>你问的问题是否太过抽象？我有拖延症怎么办？我总是很紧张怎么办？此类提问反映了其思维模式。</p>
<p>-&gt; 遇到哪些人&#x2F;哪些场合紧张？什么时候不紧张？用近的语言，亦即近的思维模式去思考<strong>真实的</strong>问题。说因为内向故而紧张，过于概括，过远，远离了真实问题。</p>
<ul>
<li><p>想象代替看见，脑补代替现实：以为了解了现实，实际上没有。不要去看没有发生的事情。</p>
</li>
<li><p>以有用、无用的判断和评价代替行动：根据可能的结果来判断是否去做，但很多时候做了才知道是否有用。结果不可控，但做不做可以。</p>
</li>
</ul>
<p>我们现在能做什么？你愿不愿意去做？不愿做是现在，为何不愿在远方。</p>
<p>远的思维：让我们远离真实的生活，失去对生活的控制感。</p>
<p>正念：原为佛教术语，现在心理学界亦流行。关注此时此刻，关注当下。是一种近的思维方式。只有近的东西是你能控制和把握的，也只有近的东西才是你存在的现实。</p>
<h1 id="12、怎样跟自己的过去告别？心理重生"><a href="#12、怎样跟自己的过去告别？心理重生" class="headerlink" title="12、怎样跟自己的过去告别？心理重生"></a>12、怎样跟自己的过去告别？心理重生</h1><p>如何面对生活的变动，面对生活中的结束和开始。</p>
<p>上一次重要的生活转变发生在什么时候？</p>
<p>转变：社会意义上，有积极者，也有消极者。所有转变都伴有压力，因内心需要调整。回顾起来，顺理成章，这是记忆之作品耳。手足无措，焦虑。转变的过程，伴有大量的失控（此为很多人不愿改变之原因？）。</p>
<p>何者可控？何者不可控？</p>
<ul>
<li><p>不可控：迷茫与混乱，失恋；</p>
</li>
<li><p>可控：知道自己会经历什么，勇敢走出，迎接新生活。</p>
</li>
</ul>
<p>威廉·布里奇斯《转变》，转变三阶段：结束、迷茫、重生。转变自结束始。</p>
<p>如何开始新生活？试图直接跨过前两阶段。无法转变入下一阶段，可能是因为在结束处卡主了。</p>
<p>案例：失恋三年，依旧关注ex之微博，尽管早已没有自己之痕迹。曰：我难过，故感情仍在。若我好了，那感情就真地结束了。此一执念，或许对当事人仍有意义，但旁观者会发现，感情“事实上”已经结束了，不管你是否接受。（如《海边的曼彻斯特》）。你所需要的是生活在对上一段感情或ex的留恋中？还是希望幸福？那么幸福是来自于留恋还是更真实的感情呢？</p>
<p>停留在过去，有何好处？内心留有一些虚幻的希望，以此对抗孤独。承认结束，就承认永远失去了一个人（但你从不曾拥有一个人，对吗）。结束总是包含了失去。这种失去也包含一部分<strong>旧的自我</strong>。</p>
<p>这就又回到了：妄图控制不可控者。</p>
<p>但结束了，不会立即进入重生，还有第二个阶段：<strong>迷茫</strong>。伴随着抑郁、自我否定，空虚、无聊。为了摆脱空虚和无聊，会急着开始。</p>
<p>迷茫之要义：不是振作和重新开始，而是放弃抵抗，同时保持对未来的好奇，与自己相处。事情为何发生？转变意味着什么？迷茫期：等待新自我的萌芽。</p>
<p>第三阶段：<strong>重生</strong>。已能够把转变整合到自己的人生经历里。从自我中长出了新的东西。</p>
<h1 id="13、你是不是也在摸索生命的意义？接受无常。"><a href="#13、你是不是也在摸索生命的意义？接受无常。" class="headerlink" title="13、你是不是也在摸索生命的意义？接受无常。"></a>13、你是不是也在摸索生命的意义？接受无常。</h1><p>生命及人类之产生纯属偶然，人终将死去，甚至地球也会消失，那么人所做的一切有何意义？</p>
<p>一个东西，无论是花还是人，它的存在本身都是有其意义的，不需要用有用来证明，也不需要用时间上的延续来证明。把任何东西当成达到目的的一种手段，都是对它本身的贬低。</p>
<p><strong>可控&#x2F;不可控</strong>视角，也许能减轻焦虑，或达到幸福，但并不是因为这个而采用，而是因为它本身就是对的。</p>
<p><strong>随缘</strong>：你遇到什么，就享受什么，但不要留恋。</p>
<p>佛祖说：”阿难陀，你看，这灵鹫山多美！“</p>
<p>纵使落日稍纵即逝，也无法消减它那刻的美。</p>
<h1 id="道理，终究是远的，切记。"><a href="#道理，终究是远的，切记。" class="headerlink" title="道理，终究是远的，切记。"></a>道理，终究是远的，切记。</h1>
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://anderscui.github.io/2017/10/03/atypical/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Anders Cui">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="mathacker">
      <meta itemprop="description" content="时光中的碎片">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | mathacker">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2017/10/03/atypical/" class="post-title-link" itemprop="url">非典型孤独（atypical）</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2017-10-03 17:42:37" itemprop="dateCreated datePublished" datetime="2017-10-03T17:42:37+08:00">2017-10-03</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2025-06-22 07:01:37" itemprop="dateModified" datetime="2025-06-22T07:01:37+08:00">2025-06-22</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>来自美剧<a href="https://movie.douban.com/subject/26895435/">非典型孤独（Atypical）</a></p>
<hr>
<h1 id="Nobody’s-normal"><a href="#Nobody’s-normal" class="headerlink" title="Nobody’s normal"></a>Nobody’s normal</h1><p>在剧中山姆被诊断为患有自闭症，还提到他是一个高功能自闭症，以及自闭症不能完全治愈。如果你看过《生活大爆炸》，也许会想到谢耳朵，其饰演者吉姆·帕森斯认为谢耳朵的表现很接近于阿斯伯格综合征。同时IMDB的剧集简介中提到了自闭症光谱。我想，有必要先了解一下这几个术语，下面相关术语的信息摘自维基。</p>
<h2 id="自闭症"><a href="#自闭症" class="headerlink" title="自闭症"></a>自闭症</h2><p>自闭症（Autism）为一种脑部因发育障碍所导致的疾病，其特征是情绪表达困难、社交互动障碍、语言和非语言的沟通有问题，以及日常上常见的，表现出限制的行为与重复的动作，明显的特定兴趣。不能进行正常的语言表达和社交活动，常做一些刻板和守旧性的动作和行为。自闭症的病因仍然未知，很多研究人员怀疑自闭症是由基因控制，再由环境因素触发。</p>
<p>部分自闭症患者可经过诊疗、实习及特殊教育，可改善他们的社交能力，而可参与主流教育及社交活动。<strong>但以现时医疗科技水平来说，并不可能完整根治自闭症，仅是提升自闭儿的功能</strong>。</p>
<h2 id="高功能自闭症"><a href="#高功能自闭症" class="headerlink" title="高功能自闭症"></a>高功能自闭症</h2><p>高功能自闭症（High-functioning autism，简称HFA），指智商中等或更高的自闭症患者，且多数具有语言能力，学习能力较佳、自闭倾向较不明显；但语言理解与表达力、人际互动与聊天的能力仍有困难的自闭症患者。</p>
<h2 id="阿斯伯格综合征"><a href="#阿斯伯格综合征" class="headerlink" title="阿斯伯格综合征"></a>阿斯伯格综合征</h2><p>阿斯伯格综合征（Asperger syndrome，简称AS），属一种发展障碍，其重要特征是社交与非言语交际的困难，同时伴随着兴趣狭隘及重复特定行为，但相较于其他泛自闭症障碍，仍相对保有语言及认知发展。亚斯伯格症患者的智力正常，其中有许多人智商偏高具有天赋，只有极少数的人属于高智商，经常出现肢体笨拙和语言表达方式异常等状况，偶尔会发出怪声音，但并不作为诊断依据。其症状一般在两岁前出现，并伴随患者终生，目前没有有效治疗方法，预后差。</p>
<h2 id="自闭症光谱"><a href="#自闭症光谱" class="headerlink" title="自闭症光谱"></a>自闭症光谱</h2><p>自闭症光谱（Autism spectrum）是一种心理状况的谱系障碍，亦称自闭症谱系障碍或泛自闭症障碍，描述了一个被DSM-5（精神障碍诊断与统计手册（第5版））归类为神经发展综合征的症状群的范围。 被诊断为自闭症（autism spectrum disorder (ASD)）的人必须存在下列两个症状。</p>
<ul>
<li>缺乏社交沟通与社交互动。（或社交及沟通上的广泛性异常）</li>
<li>局限的、重复的行为、兴趣或活动。（或异常局限性的兴趣、高度重复性的行为）</li>
</ul>
<p>自闭症光谱有三个主要项目：自闭症、亚斯伯格综合征、待分类的广泛性发展障碍。自闭症在光谱核心位置，而阿斯伯格综合征在手册（第5版）中被移除。</p>
<hr>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://anderscui.github.io/2017/09/24/hello-rust/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Anders Cui">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="mathacker">
      <meta itemprop="description" content="时光中的碎片">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | mathacker">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2017/09/24/hello-rust/" class="post-title-link" itemprop="url">Hello, Rust</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2017-09-24 23:06:09" itemprop="dateCreated datePublished" datetime="2017-09-24T23:06:09+08:00">2017-09-24</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2025-06-22 07:01:37" itemprop="dateModified" datetime="2025-06-22T07:01:37+08:00">2025-06-22</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># On Mac</span><br><span class="line">$ curl https://sh.rustup.rs -sSf | sh</span><br></pre></td></tr></table></figure>

<p>运行此命令，按其中的提示安装即可。</p>
<h2 id="升级与卸载"><a href="#升级与卸载" class="headerlink" title="升级与卸载"></a>升级与卸载</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ rustup update</span><br><span class="line"></span><br><span class="line">$ rustup self uninstall</span><br></pre></td></tr></table></figure>

<h2 id="确认"><a href="#确认" class="headerlink" title="确认"></a>确认</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ rustc --version</span><br></pre></td></tr></table></figure>

<h2 id="本地文档"><a href="#本地文档" class="headerlink" title="本地文档"></a>本地文档</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 使用此命令在浏览器中打开本地文档，其中包含 The Rust Programming Language.</span><br><span class="line">$rustup doc</span><br></pre></td></tr></table></figure>

<h1 id="Hello-World"><a href="#Hello-World" class="headerlink" title="Hello, World!"></a>Hello, World!</h1><p>假设把代码放在某个目录下，cd到它，创建一个<code>main.rs</code>文件（rs是Rust文件的扩展名）：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Hello, world!&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后，编译再运行之：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ rustc main.rs</span><br><span class="line">$ ./main</span><br></pre></td></tr></table></figure>

<h2 id="Rust程序的结构"><a href="#Rust程序的结构" class="headerlink" title="Rust程序的结构"></a>Rust程序的结构</h2><p><code>fn</code>定义一个函数，而<code>main</code>同时是特别的<strong>入口函数</strong>，与<code>C</code>和<code>C#</code>之类语言类似。Rust中的函数需要花括号包含其函数体。</p>
<p>第二行<code>println!(&quot;Hello, world!&quot;);</code>，输出一行文本到屏幕。这里看起来有点特别的是<code>println!</code>，带有<code>!</code>在Rust中意味着调用宏而非函数。行末的<code>;</code>表示一个表达式的结束，<strong>大多数</strong>Rust代码行以<code>;</code>结束。</p>
<h1 id="编译和执行的分离"><a href="#编译和执行的分离" class="headerlink" title="编译和执行的分离"></a>编译和执行的分离</h1><p>作为静态语言，Rust程序执行之前需要先行编译，这类似于<code>gcc</code>或<code>clang</code>。</p>
<p>对于简单的程序，可如上使用<code>rustc</code>，对于更为复杂的程序，你可能需要<code>Cargo</code>这个工具。</p>
<h1 id="Cargo"><a href="#Cargo" class="headerlink" title="Cargo"></a>Cargo</h1><p><code>Cargo</code>是Rust的构建系统（Build System）和包管理器（Package Manager）。它可以生成代码、下载依赖库，生成库代码。</p>
<p><code>Cargo</code>随Rust一起安装。</p>
<h2 id="以Cargo创建一个项目"><a href="#以Cargo创建一个项目" class="headerlink" title="以Cargo创建一个项目"></a>以Cargo创建一个项目</h2><p>使用命令</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ cargo new hello_cargo --bin</span><br></pre></td></tr></table></figure>

<p>创建一个项目，<code>--bin</code>表示所创建者为可执行文件（binaries）。<code>Cargo</code>生成了两个文件：</p>
<ul>
<li>Cargo.toml（TOML格式的配置文件）</li>
<li>src&#x2F;main.rs（与上面手工创建的一样）</li>
</ul>
<p>Cargo.toml内容如下：</p>
<figure class="highlight toml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[package]</span></span><br><span class="line"><span class="attr">name</span> = <span class="string">&quot;hello_cargo&quot;</span></span><br><span class="line"><span class="attr">version</span> = <span class="string">&quot;0.1.0&quot;</span></span><br><span class="line"><span class="attr">authors</span> = [<span class="string">&quot;andersc &lt;andersc@mail.com&gt;&quot;</span>]</span><br><span class="line"></span><br><span class="line"><span class="section">[dependencies]</span></span><br></pre></td></tr></table></figure>

<p><code>[dependencies]</code>列出了依赖的库，这些依赖在Rust中称为<code>crate</code>。Cargo创建了初始的目录结构，也是建议将代码放在src下，其它文件放在顶级目录。</p>
<h2 id="Building-and-Running-a-Cargo-Project"><a href="#Building-and-Running-a-Cargo-Project" class="headerlink" title="Building and Running a Cargo Project"></a>Building and Running a Cargo Project</h2><p>使用如下命令编译并运行程序：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ cargo build</span><br><span class="line">$ ./target/debug/hello_cargo</span><br></pre></td></tr></table></figure>

<p>首次执行<code>cargo build</code>时，它会创建文件<code>Cargo.lock</code>，用于跟踪应用的依赖。一般不需要手工改动之。作为一种更快捷的方式，可以用<code>cargo run</code>来编译并运行程序。</p>
<h2 id="发布程序"><a href="#发布程序" class="headerlink" title="发布程序"></a>发布程序</h2><p>上面可见，编译的程序放在了<code>debug</code>下，如果要正式发布，则应使用<code>cargo build --release</code>选项，这会优化所生成的程序，代价是编译时间更长。</p>
<h1 id="开发环境"><a href="#开发环境" class="headerlink" title="开发环境"></a>开发环境</h1><ul>
<li>Sublime 3：<a href="https://github.com/rust-lang/sublime-rust">Sublime Rust</a></li>
<li><a href="https://intellij-rust.github.io/">IntelliJ Rust</a></li>
</ul>
<h1 id="Guessing-Game"><a href="#Guessing-Game" class="headerlink" title="Guessing Game"></a>Guessing Game</h1><p>通过一个真实的程序来演示几个Rust的常见概念，如<code>let</code>， <code>match</code>，方法，关联函数，使用外部库等。</p>
<p>猜数游戏是一个经典的编程初学者的问题。</p>
<h2 id="建立项目"><a href="#建立项目" class="headerlink" title="建立项目"></a>建立项目</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">cargo new guessing_game --bin</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">cd</span> guessing_game</span></span><br></pre></td></tr></table></figure>

<h2 id="感受一下"><a href="#感受一下" class="headerlink" title="感受一下"></a>感受一下</h2><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::io;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Guess the number!&quot;</span>);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Please input your guess.&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">guess</span> = <span class="type">String</span>::<span class="title function_ invoke__">new</span>();</span><br><span class="line">    io::<span class="title function_ invoke__">stdin</span>().<span class="title function_ invoke__">read_line</span>(&amp;<span class="keyword">mut</span> guess)</span><br><span class="line">               .<span class="title function_ invoke__">expect</span>(<span class="string">&quot;Failed to read line&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;You guessed: &#123;&#125;&quot;</span>, guess);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里面，<code>use</code>不用多说；let创建一个<strong>变量</strong>，不过在Rust中变量默认是不可修改的，如果希望修改，则需要使用<strong>mut</strong>；String:new()就是所谓关联函数（associated function），相当于其它语言中的<strong>静态方法</strong>。</p>
<p><code>stdin</code>是io的关联函数；read_line函数读取用户输入，将值赋给一个变量，<code>&amp;</code>表示参数为<strong>引用（reference）</strong>。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://anderscui.github.io/2017/09/24/happiness/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Anders Cui">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="mathacker">
      <meta itemprop="description" content="时光中的碎片">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | mathacker">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2017/09/24/happiness/" class="post-title-link" itemprop="url">《幸福课》笔记</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2017-09-24 04:08:04" itemprop="dateCreated datePublished" datetime="2017-09-24T04:08:04+08:00">2017-09-24</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2025-06-22 07:01:37" itemprop="dateModified" datetime="2025-06-22T07:01:37+08:00">2025-06-22</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p><a href="https://book.douban.com/subject/27050457/">原书信息</a></p>
<blockquote>
<p>陈海贤（动机在杭州），浙江大学心理学博士，中国临床心理学会注册心理师。曾在浙江大学心理中心任职，期间开设《积极心理学》的通识课，广受欢迎，被誉为浙江大学版的“幸福课”。</p>
</blockquote>
<blockquote>
<p>你大概也正处于某种“匮乏”当中，也因此，你的内心会有种种不安。这些不安一方面推动你去想象未来、远方、更好的自己，让你急着想要成长和改变；另一方面，也容易让你对自己、对世界采取一种防御的姿态，让你在自我怀疑中裹足不前。所以，你经常觉得自己敏感内向；你有关于未来生活的远大设想，却总会责怪自己没有足够的意志力去执行它；你一边焦虑自己变平庸，一边害怕竞争的激烈；你会为如何与他人相处头疼，会纠结于他人的负面评价；有时候你会害怕孤独，有时候又宁可回归孤独；偶尔，你还会感到空虚沮丧，并经常怀疑人生的意义……</p>
</blockquote>
<blockquote>
<p>如果是这样，那这本书就是为你写的。</p>
</blockquote>
<p>如果你也感到焦虑，因焦虑而焦虑；总感觉时间不够用，但内心却深知，自己并没有利用好时间；不允许自己闲下来；</p>
<h1 id="自序"><a href="#自序" class="headerlink" title="自序"></a>自序</h1><p><del>&gt; 追求幸福如登山，登顶只是瞬间的事，而攀爬的过程却艰辛而漫长。</del></p>
<p><del>你也许爬过一座山，却未必爬过他人在爬的山，或者未走过他在走的那条路，仅能给出一点建议而已。</del></p>
<blockquote>
<p>幸福之路，坑多路少。原因之一是，我们生活在一个<strong>不完美、充满缺陷的世界</strong>中。<strong>幸福需要我们承认这种不完美，扎根于这种不完美，并从中感受真实的生机。而太多的人生问题，是因为我们想要逃离这种不完美。</strong></p>
</blockquote>
<blockquote>
<p>如果你总致力于怎么把生活打扫得一尘不染，你就不会知道在泥浆里跳舞的快乐。</p>
</blockquote>
<p>如果我们能接受世界本来的不完美，许多问题就不是问题了。（当我们憧憬未来、努力上进，似乎都在暗示着：现在的自己不够好。）</p>
<p>现实有各种限制，先天的、后天的，自我的、他人的。想象的幸福是什么样的呢？或许也能想到某些限制，但总是不够多。要走出想象，努力去生活，进入生活本身。这样才能更了解自己的能力和限制，唯有如此，才能有更合理的想象。真正了解生活的限制，才能有自由，就像一只鱼儿不会因为不能飞翔而感到悲伤。</p>
<blockquote>
<p>你大概也正处于某种“匮乏”当中，也因此，你的内心会有种种不安。这些不安一方面推动你去想象未来、远方、更好的自己，让你急着想要成长和改变；另一方面，也容易让你对自己、对世界采取一种防御的姿态，让你在自我怀疑中裹足不前。所以，你经常觉得自己敏感内向；你有关于未来生活的远大设想，却总会责怪自己没有足够的意志力去执行它；你一边焦虑自己变平庸，一边害怕竞争的激烈；你会为如何与他人相处头疼，会纠结于他人的负面评价；有时候你会害怕孤独，有时候又宁可回归孤独；偶尔，你还会感到空虚沮丧，并经常怀疑人生的意义……</p>
</blockquote>
<p>匮乏，将限制我们的目光，使其短视和失焦。</p>
<p>如意与不如意者，要么减小后者，要么扩大后者。</p>
<blockquote>
<p>但只有在行驶中，你才知道该怎么调整、转向、把握平衡。</p>
</blockquote>
<blockquote>
<p>如果说本书中让我们焦虑的“远方”是<strong>完美又脆弱的虚假自尊</strong>，<strong>抽象又缥缈的高远目标</strong>，对成为一个很厉害的人的期待，快速免于匮乏的想象，高效专注、心无旁骛的状态，左右逢源、八面玲珑的人格，与父母和朋友的完美关系……那“脚下”则是把失败当作反馈的成长思维、认真对待琐事的无差别心、不功利的兴趣和努力、匮乏和不安中的淡定从容、内疚与自责中的自我和解、对性格优势和缺陷的了解和接纳、在不完美关系中的自我滋养……</p>
</blockquote>
<blockquote>
<p>这些“远方”都很好，唯一的问题是，<strong>它既不像这个真实的世界，也不像我们真正的自己</strong>。它是我们应对匮乏和不安的想象，并不是真实的幸福。而“脚下”呢，说不上好，也说不上坏，但我们踩下的每一步都很踏实。</p>
</blockquote>
<h1 id="假想的自我与真实的成长"><a href="#假想的自我与真实的成长" class="headerlink" title="假想的自我与真实的成长"></a>假想的自我与真实的成长</h1><blockquote>
<p>我非理想中的我，我非将来的我，我亦非过去的我。</p>
</blockquote>
<h2 id="名校学生病"><a href="#名校学生病" class="headerlink" title="名校学生病"></a>名校学生病</h2><blockquote>
<p>考败来浙；严格的父母；严苛的高中，唯成绩论；身边总有更好的人（成绩好，专业有趣，有前途）；</p>
</blockquote>
<p>PS：成绩天然带有对比。</p>
<blockquote>
<p>但如果真让他无所事事一会儿，哪怕几分钟，他就会被“变平庸”的恐惧和焦虑折磨。</p>
</blockquote>
<p>此时的“努力”已经走样。少有成功的喜悦，却多失败的恐惧。</p>
<h2 id="假想中的完美自我"><a href="#假想中的完美自我" class="headerlink" title="假想中的完美自我"></a>假想中的完美自我</h2><blockquote>
<p>感到安全时，人天生就有探索世界、接受挑战的冲动，这是我们<strong>做事的内在动机</strong>。但是，这种内在动机很容易被破坏。</p>
</blockquote>
<p>比如评价性语言，褒贬、施压、攀比。无论褒贬，评价容易带来不安，陷入防御心态和过度的自我关注。</p>
<blockquote>
<p>当儿童担心自己不被父母或他人认可时，他们会产生强烈的焦虑和不安。于是，他们会在幻想中创造出一个他们认为的、父母喜爱的“自我”，来缓解这种焦虑。这个假想的自我通常都是完美的——聪明、美丽、优秀，毫无瑕疵。当他们用幻想的自我来对照现实的自我时，他们会觉得自己像个冒牌货。他们努力维持幻想中的形象，害怕别人看到幻想背后真实的自己。</p>
</blockquote>
<p>即使别人真诚地以为他们已经做得很好。</p>
<blockquote>
<p>在心理结构中，自我像是一个调节器或维修包。当一切运转良好时，我们会把生命能量投射到与外部世界的互动中。世界向我们提问，我们努力解答。自我也在与世界的互动中逐渐变得丰富起来。但是如果我们感到不安，就会把注意力投射到自我本身，就像打开维修包里的探测器，去探索和发现自己的问题。</p>
</blockquote>
<blockquote>
<p>当我们把注意力放到自我修正时，自我的发展却因为缺乏与真实世界的互动而逐渐停滞了。越停滞，我们越想修正自我，越容易变得以自我为中心，这形成了恶性循环。</p>
</blockquote>
<blockquote>
<p>不安全感也可能是一种动力，但它和自发的、通过挑战获得成就感的动力并不相同。很多心理学家以不同的术语区分了这两种动力：追求成功的动机和避免失败的动机（阿特金森），指向成长的动机和满足匮乏的动机（马斯洛）……而斯坦福大学心理学教授德韦克认为，这两种动力背后，是<strong>两种不同的心智模式：成长型思维和僵固型思维</strong>。</p>
</blockquote>
<h2 id="成长型思维和僵固型思维"><a href="#成长型思维和僵固型思维" class="headerlink" title="成长型思维和僵固型思维"></a>成长型思维和僵固型思维</h2><p>两种心智模式，对于<strong>拖延症</strong>有着重要的影响。它们的区别在于注重成长的可能性，还是当前的评价，前者开放，后者封闭。</p>
<p>它们决定了一个人如何看待挑战、失败、努力（努力证明自己的无能？）、批评。如何看待他人的成功？</p>
<blockquote>
<p>仔细思索，你会发现成长型思维的底层是安全感。这种安全感不是因为“我是一个什么样的人”，而是因为“我有很多可能性”。<strong>拥有这种安全感的人，不需要保护某种特定的自我观念，也不需要过度的自我关注</strong>。他们突破了自我中心的束缚，转而从成长和发展的角度看问题。在这种视角下，“自我”并不是一种固定的状态，而是一个不断创造和形成自身的过程。</p>
</blockquote>
<p>做到原以为做不到的事情；回想三年前的自己，是否有很大进步？</p>
<p>不太关注结果，专心做事，结果反而更好；</p>
<blockquote>
<p>成长究竟是怎么发生的？从微观层面看，人的大脑由各种各样的神经元组成，这些神经元的连接方式构成了我们储存和加工信息的能力。未知的挑战一方面让我们焦虑，另一方面也在不断训练我们的大脑。挑战越多，大脑就会变得越复杂，相应地，人的能力也在不断增长。</p>
</blockquote>
<blockquote>
<p>从宏观层面看，人的能力是通过与环境的互动成长起来的。我们与环境的互动越多，获得的反馈机会就越多，我们的能力成长就越快。</p>
</blockquote>
<blockquote>
<p>这种成长和进步的路径需要我们重新思考失败和错误的价值。曾有一个来访者问我：“总是为说错话、做错事懊恼不已，担心自己还会犯错误，影响工作和生活，该怎么办？”</p>
</blockquote>
<blockquote>
<p>对他来说，<strong>错误意味着失败和对自己的否定</strong>。他很少<strong>从反馈的角度理解错误</strong>。</p>
</blockquote>
<p>从而最直接的表现就是畏手畏脚。</p>
<h2 id="成长中的关系"><a href="#成长中的关系" class="headerlink" title="成长中的关系"></a>成长中的关系</h2><blockquote>
<p>布尼尔祈祷文中几句经典的祈祷词，是这样的：</p>
</blockquote>
<blockquote>
<p>上帝啊，请赐予我胸怀，让我接受无法改变的事；请赐予我勇气，让我改变能够改变的事；请赐予我智慧，让我能够分辨这两者。”</p>
</blockquote>
<blockquote>
<p>多么言简意赅、简单实用又发人深省！简直道尽了所有鸡汤的精髓。</p>
</blockquote>
<p>常见者：一眼就觉得不合适，分手。但实际上关系也可以成长。</p>
<p>若你相信能在一期，可能就在一起了，若不相信那也就不可能在一起了。相信才会去为之做些什么。</p>
<blockquote>
<p>你相信你们俩的关系是一成不变的还是不断成长的？以及，你对自己的信念有多坚定？</p>
</blockquote>
<blockquote>
<p>“相信”这事，说来缥缈，却力量巨大。你相信什么，往往决定了你怎么看待你们之间的关系，以及采取什么样的行动来处理你们的关系。而看法和行动，又会进一步影响你们的关系。</p>
</blockquote>
<p>一见钟情&#x2F;性格不合&#x2F;三观不一致&#x2F;没感觉 vs. 开放的好奇心</p>
<blockquote>
<p>秉持成长型思维的人，更容易相信关系是不断成长的，也因此更愿意投入精力来经营和改善这段关系。</p>
</blockquote>
<p>相处中亦有正反馈。</p>
<h2 id="像一棵树一样成长"><a href="#像一棵树一样成长" class="headerlink" title="像一棵树一样成长"></a>像一棵树一样成长</h2><blockquote>
<p>曾有学生问我这样的问题：“假如兔子都在拼命奔跑，作为乌龟的你，前进的动力在哪里？”</p>
</blockquote>
<blockquote>
<p>根据心理学家海德特的说法，人格的核心，其实是一个故事。</p>
</blockquote>
<blockquote>
<p>这个故事凝缩了我们对整个人生的理解，成了我们独特的人生线索。这个故事有一个目标，通常就是成功或幸福；有很多围绕目标展开的情节，就是你的每段人生经历。而我们的<strong>意义感，也通常源于对这个人生故事的理解</strong>。可以说，我们的人生就在完成这样一个独特的故事。只是，<strong>故事开始的时候，我们也不知道这个故事是怎样的</strong>。我们一边当观众，一边当编剧；一边经历，一边修改故事大纲。</p>
</blockquote>
<blockquote>
<p>当我们接受一个故事作为我们人生范本的时候，我们也接受了这个故事背后所隐含的假设。这些假设像是故事的潜台词，它被视为理所当然，很少有人认出它，去质疑它。</p>
</blockquote>
<blockquote>
<p>当我们用龟兔赛跑来比喻我们的人生时，它同样隐含了我们对人生的一些信念：</p>
</blockquote>
<ul>
<li>人生是一场赛跑：必须要和别人比赛吗？</li>
<li>终点处只有一个胜利者：一定要分出胜负吗？只能有一个胜者吗？</li>
<li>跑得快还是慢，是一种固定的能力。如果你跑得慢，你就一直跑得慢。</li>
<li>奔跑很辛苦。但既然你已经跑得很慢了，就只有拼命奔跑，才能获得成功。</li>
</ul>
<blockquote>
<p>这些隐含的信念所体现的，正是僵固型思维的特征：用一个假设的、“必然会存在”的、比我们强的人作为比较标准，来<strong>消减我们成长和进步的意义</strong>。</p>
</blockquote>
<p>它们来自：焦虑的父母、功利的学校、浮躁而现实的社会文化共同的产物？</p>
<p>同时，也会有人<strong>假设自我是一个已经存在并相对固定的东西</strong>。它通常由我们的童年经历决定，而我们以后的经历，只是对已经形成的自我的修修补补。</p>
<p>那么，还可以选择什么样的故事呢？一条河流或一颗树。</p>
<blockquote>
<p>源头固然很重要，但它最终的形态如何，取决于它在流向大海的途中会遇到哪些山坡、丘陵、沙漠……它怎么面对障碍，以及选择在什么地方拐弯。真实的自己并不是一开始就存在，它是我们在跟环境的互动中，在应对困难、做出选择的过程中，逐渐塑造出来的。</p>
</blockquote>
<blockquote>
<p>假如自我是一条流动的、尚未成形的河流，那么“发现自我”，或者“证明自我”也就没有意义。因为就算我们能通过某件事证明自己，我们所能证明的，也仅仅是某个阶段、某种状态下的自己。就像这条河流会有一段湍急、有一段平缓，你却没法通过单一的某段河流来评判它。</p>
</blockquote>
<p>源头能决定你是黄河还是长江，我们却不能简单地说长江是什么河，它有湍急的三峡，也有开阔平稳的河段，还接纳了不知多少条支流。</p>
<blockquote>
<p>这是我见过的关于成长型自我最好的隐喻。</p>
</blockquote>
<blockquote>
<p>如果从树的角度，重新回答开头那个同学的问题，我大概会说，人和人之间的关系，并不只有比较和竞争。我们做事的动力，也不只是想比别人优越。我们每个人都努力生长，既相互竞争，又彼此扶持，形成了一个完整的生态系统。我们是亲人、朋友、同学、同事、公民……也许我们有高有低，但我们在共同生长的土地下面根须相连。如果你问一棵树为什么还要生长，既然总有其他树比它长得高。它大概会回答：“傻孩子，因为我是一棵树啊。”</p>
</blockquote>
<p>如何面对现实中的评价体系？不要简单地认为，一件事情非得如此如此不可，很多时候还是有选择的。一定要赚很多钱吗？一定要买大房子吗？孩子一定要去最好的学区吗？</p>
<h1 id="更大的世界与眼前的生活"><a href="#更大的世界与眼前的生活" class="headerlink" title="更大的世界与眼前的生活"></a>更大的世界与眼前的生活</h1><p>较之于当下在我们之内的，我们身后的过去和眼前的未来，都是琐事。<br>	– 奥利弗·温德尔·霍姆斯<br>	<br>很多人都生活在平静的绝望中。<br>	– 梭罗</p>
<p>从眼前的琐事到更远的地方。</p>
<h2 id="世界那么大，我想去看看，然后呢？"><a href="#世界那么大，我想去看看，然后呢？" class="headerlink" title="世界那么大，我想去看看，然后呢？"></a>世界那么大，我想去看看，然后呢？</h2><blockquote>
<p>英雄就是要反抗我们想反抗又不敢反抗的势力，做我们想做又不敢做的事情。我们从英雄故事中吸收力量，寻找榜样。对于每一个深陷琐碎的日常、<strong>只能在夜深人静的时候透过窗户遥想外面世界的人</strong>，这封文艺的辞职信足够提供想象的素材，成为我们编织英雄梦想的线索。</p>
</blockquote>
<blockquote>
<p>人能忍受辛苦，但很难忍受停滞的感觉。他们在<strong>努力探索生活的可能性</strong>。</p>
</blockquote>
<p>你觉得外面有更大的世界，但你的世界可能是另一些人更大的世界。即对绝大多数人来说，总有“更大的世界”，更大的世界在<strong>远方</strong>。</p>
<blockquote>
<p>看来对大部分人来说，“更大的世界”都不在此时此地，而在“远方”。它意味着变化、希望、丰富的体验和更多的可能性。</p>
</blockquote>
<p>变化、希望、可能性都在未来。我们可以去想象，但一定要清醒地认识到，只是想象，永不能到达远方，而且远方亦有其远方。</p>
<p>世间的一切，唯有内心感受到的才是真实的。若只是走马观花，你自己都不愿相信“去过”那个地方。故更大的空间不是最重要的，要内心有更丰富的体验。</p>
<p>行万里路，为的是回归内心。而回归内心，则不惟行万里路一途。</p>
<blockquote>
<p>“远方”是一个充满诱惑的神奇的词。卡尔维诺说，对远方的思念、空虚感、期待，可以延绵不绝，比生命更长久。这种思念究其本质，就是<strong>对生命可能性的向往</strong>。当人们陷于生活的琐碎无聊、疲惫厌倦时，“远方”就会在幻想中被制造出来。它所代表的可能性，既能容纳过去的失败、挫折和悔恨，又能容纳未来的希望。</p>
</blockquote>
<p>当前所经历的生活，不是可能性，而是“确然性”。因对其不满意，故而期望其它的可能性。</p>
<blockquote>
<p>“远方”的意义到底在哪里？人们心里有疑惑，去远方寻找答案。答案并不在“远方”，而在寻找的过程本身。</p>
</blockquote>
<p>以前想过，远方的意义在于，让自己抽身出来，面对自我，因为平日里面对的多是身外之事。如果能够抽身，那么都可以面对自己。此处与彼处，都可以去寻找，都可以在寻找的过程中找到某些答案。</p>
<blockquote>
<p>一件事是不是琐事，并不是由这件事的性质决定的，而是由你对待它的态度决定的。</p>
</blockquote>
<p>身在此处或彼处，都有“琐事”，不愿做琐事，即意味着只要结果，不要过程。这不是一种现实的态度，要记住，在去往彼处的途中，各种琐事、趣事都是其必然包含的，要想到目的地，也要想到如何到达。一个目的地如此，整个生活也是。</p>
<blockquote>
<p>他们并不对无聊琐事失望，相反，心自由了，他们对什么样的生活都充满热情。他们哪里也不想去，却反而自由了。而那些想要逃离的人，却到处看到囚牢。</p>
</blockquote>
<blockquote>
<p>我们总是习惯了用“好”“坏”“重要”“不重要”来<strong>评价</strong>一件事。这件事能帮助我们升职加薪吗？能够帮助我们快速成长吗？评价并不总会带来“意义感”——有时候，意义感是我们沉浸在一件事中体会到的。<strong>但评价却经常带来“无意义感”</strong>。</p>
</blockquote>
<blockquote>
<p>而我们对生命的态度，除了沉下心来体验，还能做什么呢？</p>
</blockquote>
<blockquote>
<p>很多人总是容易把做“正事”的时间看作“我的时间”，而把做琐事的时间看作“占用了我的时间”，好像那一段时间不再属于他了。而实际上，陪伴孩子的时间和修行的时间一样，都是“我的时间”，我们有责任以认真的态度度过它。</p>
</blockquote>
<p>如果一件事情“占用了你的时间”，你可不可以不去做呢？如果必须要去做，那么它不就是你时间的一部分吗？自己的时间，为什么不认真对待呢？</p>
<h2 id="过程本身也是目的"><a href="#过程本身也是目的" class="headerlink" title="过程本身也是目的"></a>过程本身也是目的</h2><blockquote>
<p>《禅与摩托车维修艺术》中的一句话：“今天，佛陀或是耶稣坐在电脑和变速器的齿轮旁边修行，会像坐在山顶和莲花座上一样自在。如果情形不是如此，那无异于亵渎了佛陀——也就亵渎了你自己。”</p>
</blockquote>
<p>多隆成为大神的过程中，驱动力是什么？</p>
<blockquote>
<p>不是高远的目标。如果他念念不忘远大目标，未必能做到这么专注。人心里有了执念，就会有担心。一担心，就很难做到专注了。</p>
</blockquote>
<p>当然可以有高远的目标，但在每个当下，却不能时时想着它。高远的目标指引了方向，当下的事情则让自己迈出一步步。不积跬步，到不了；走偏了，也到不了。</p>
<p>前行，省视，反馈，继续前行，如此确保，不忘方向，亦不走偏。</p>
<blockquote>
<p>要有远大理想，这几乎成了我们对世界的基本信条。越是对现实不满，越是害怕泯于众人，我们越会紧紧抓住高远的目标不放。但如果高远目标没有现实的路径，就很容易把生活变得抽象而无趣。</p>
</blockquote>
<p>因其高远，路径难现，且他人之路径亦他人耳，未必适合自己。想太多高远的事物，会让每一个当下的时刻“抽象而无趣”，这是真的。</p>
<p>远处的目标固然是想要的，但一个事实是，眼下的每一刻却是我们能经历和体验的所有。只要结果，不要过程？没有过程，何来结果？</p>
<p>再者，结果不可控，过程则可以。</p>
<blockquote>
<p>我们总是东张西望，觉得只有有人给了我们这样的保证，才舍得全情投入。古人说，尽人事，安天命。说的是，做我们能做的事，把命运的部分交给命运。这里面有一种信任。这种信任并不是对“公平买卖”的信任，而是死心塌地地交付。不是“只要我努力投入，上天就会给我回报”，而是“即使上天不给我回报，我也会努力投入”。</p>
</blockquote>
<p>问题在于，时间只有一次，你投不投入，你做这件事或那件事，它都一样流逝。对于一件事情“不感兴趣”而不投入，不投入则更不感兴趣，这似乎是必然的结果。想一想，有哪些事情是当你沉下心来认真去做，发现它比想象地更有趣？</p>
<p>对于要做的事情，投入它；不要担心回报如何，若无投入，结果只能是——它不值得做，但事实真地如此吗？</p>
<blockquote>
<p>心理学家米哈里提出一个叫作“<strong>福流（flow）</strong>”的概念。他说，福流是人们在全情投入时所产生的一种特殊的忘我体验。在福流的状态下，人们的注意力高度集中、心中没有任何杂念，觉得一切活力畅通无阻，自己跟眼前的事密不可分、浑然一体，甚至忘记了时间。（爬山除了爬山之外，没有别的理由，它完全是一种自我沟通。）福流所描述的，大概是多隆经常会有的、沉浸于某件事的状态。米哈里把这种状态看作人类的最优体验，是幸福感真正的来源。悖论是，福流需要我们“忘我”，放下对事物以外的“目标”的执念。也正是因为“忘我”了，我们反而能够成就更深刻、更复杂的自己。</p>
</blockquote>
<p>如果你曾沉浸于解数学题、登山、下棋、篮球比赛，就能感受到，”忘我“，放下事物以外的执念与杂念，这是我们可能有的最幸福的体验。解出题来、登上山顶，却只是一瞬间的事情。</p>
<blockquote>
<p>不要以成功为目标——你越是对它念念不忘，就越有可能错过它。</p>
</blockquote>
<p>目标不因在意而自然成功，需要投入，而且能否成功，并不确定，因此更无须过于关注，努力去做即可。要记住，<strong>成功是副产品</strong>。</p>
<blockquote>
<p>能够专注于当下的事情，这就是难得的福报。</p>
</blockquote>
<h2 id="我想去远方，把人生格盘重来"><a href="#我想去远方，把人生格盘重来" class="headerlink" title="我想去远方，把人生格盘重来"></a>我想去远方，把人生格盘重来</h2><blockquote>
<p>力求每时每刻都有事做，好避免深层次的思考</p>
</blockquote>
<blockquote>
<p>这些年，我始终没发现自己热爱什么，只知道自己讨厌什么。我太害怕失败了，于是我什么也没做。</p>
</blockquote>
<p>如果遇见一个我深爱的人，我一定全力去爱；如果有一件我热爱的事情，我一定全力以赴，你也这样想过吗？那这样的人和事为何一定会出现在你面前？</p>
<blockquote>
<p>它的功能和梦很像：<strong>满足我们纠正过去生活的愿望</strong>。伤心和挫折在心里郁结越久，你的“把生活格盘重来”的念头就会停留越久，你就会忍不住想把幻想拉进现实。</p>
</blockquote>
<blockquote>
<p>这段挫折给你留下的印记太深了，以至于你无法接受这样的事实：你有过一段不太成功的大学经历。这段经历事实上已经结束了，但你在心里一直延续着它。你想要一个光明的、深V翻转的结尾，强烈到宁可不开始新的生活，也不愿意为这段经历画上一个句号。</p>
</blockquote>
<p>你现在的生活，是否真地如你所想的那么糟糕？现在回想起来，刚来上海时，你算是一个”会写程序“的程序员吗？你现在自认为是一个中等的程序员，那么是否一路是自己学过来的？没错，想起名校CS的人，差距颇大，但从起点开始，很多事情确实不是那么容易控制的。如何学习？如何学习如何学习？如何面试、找工作？如何去学习不同领域的知识？如何与人交往？如何恋爱？如何寻找soulmate？这么多问题，你不是一路摸索着过来的吗？</p>
<p>尽管与某些人有明显差距，但是你必须也要考虑自己的经历。回到22岁，某些人已经编程超过10年了，你呢？再到18岁，你或许仍会因一次考试的不理想而耿耿于怀，但是已然发生的事情，悔恨有何益？回到17岁，你仰慕爱因斯坦、欧拉，你热爱数学，但如果没错的话，你想能在数学上达到前10000就很满足了。看到了吗？在你自认为最擅长数学时，也没有那么高的期望，现在却认为这目标低得惊人。是的，我想过学好数学，但彼时亦没有”成为伟大的数学家“这种念想。再往前推，初中在放羊，极想看书时无书可看；小学还曾经有过两个班在一个教室。</p>
<p>（插播一条：大学里，认识到自己也是很平庸的，放弃数学，开始学习编程。然后，在08年前后，自认为已经学得不错了，值得注意的是，这时做编程工作仅3年，对于CS几乎是没了解的，所谓”不错“完全是幻觉。）</p>
<p>这些，你可以说不能作为借口。但是，这些是事实，如果你承认天赋与家庭的重要性，那么碰巧这两者都是无法选择的。然后，”往者不可谏“。</p>
<p>当然，你回想起来，会觉得有”本可以过得更好“的可能性，但是天赋与家庭不可选择与更改的前提下，在这个起点上，你做的看起来也还不错了。我真心如此觉得，我确定你不是自己想象地那么一无是处。至于其他人做得多好，和你没有任何关系，只需做好自己的事情，做喜欢的事情。（如果所有数学家都跟欧拉、高斯、陶哲轩相比，干脆都自杀算了）</p>
<p>另外，是之前想到的：</p>
<ul>
<li>最佳先天与最佳环境的组合毕竟也有上限，如高斯，欧拉，拉格朗日，则不如此完美者更有上限。然则作为个体，只能尽力去做，与自己相比。但上限在哪里说不清。只思考上限无意义，不能了解，亦有害于生活。不如放下执念，投入到眼前之事，踏实前行。</li>
<li>一生之上限不可了解，一个月可以，且有反馈调整。努力、反馈、自省，如此反复前行，此乃正途。</li>
</ul>
<p>总之，不能太纠结于与他人的比较，各方面条件有差别，难有合适的参考系。与自己比较，看自己与过去三年、十年有多大进步。专注于自己的事情。明白每个人，包括自己，都是有上限的，但不必担心上限在哪里，如果此上限太低会怎样，过去的已过去，着眼于当下与未来，尽力去做就好。</p>
<p>你不知道具体上限在哪，你也不希望知道，不是吗？在余生里，对生活充满热情，去体验，去实现吧：）</p>
<p>我好像说服自己了，几欲激动落泪。</p>
<blockquote>
<p>因为我们每个人都带着自己长长的过去，这些长长的过去并不会因为到了“远方”就消失。它不在环境里，而在我们的头脑里，在我们的所思所想中，在我们对挑战的应对里，在我们和环境的互动中。我们需要了解自己的想法和行为模式，需要了解它们的历史、好处和可能的问题。</p>
</blockquote>
<h2 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h2><ul>
<li>生活中的哪些时间被你当作“不是我的时间”而敷衍度过了？</li>
<li>尝试以认真投入的态度做一件琐碎的事情，比如洗碗、扫地、做饭或者照看孩子，集中注意力，全情投入，把它当作一种修行般郑重。感受事情的每个细节，观察自己在做这件事时的情绪和感受。（练习”庄严“地做事）</li>
<li></li>
</ul>
<h1 id="理想与平庸"><a href="#理想与平庸" class="headerlink" title="理想与平庸"></a>理想与平庸</h1><p>想象的自我不是真实的，是否平庸不重要，重要的是你经历和体验到了什么。</p>
<h1 id="匮乏与不安"><a href="#匮乏与不安" class="headerlink" title="匮乏与不安"></a>匮乏与不安</h1><p>爱的匮乏是最大的匮乏，匮乏让人短视。</p>
<h1 id="接纳与改变"><a href="#接纳与改变" class="headerlink" title="接纳与改变"></a>接纳与改变</h1><p>细水长流。</p>
<h1 id="拖延与不拖延"><a href="#拖延与不拖延" class="headerlink" title="拖延与不拖延"></a>拖延与不拖延</h1><p>拖延与另一个我，或真实的我。</p>
<h1 id="敏感与内向"><a href="#敏感与内向" class="headerlink" title="敏感与内向"></a>敏感与内向</h1><h1 id="爱与孤独"><a href="#爱与孤独" class="headerlink" title="爱与孤独"></a>爱与孤独</h1><h1 id="空虚和意义感"><a href="#空虚和意义感" class="headerlink" title="空虚和意义感"></a>空虚和意义感</h1><p>存在即意义。</p>
<h1 id="结束与开始"><a href="#结束与开始" class="headerlink" title="结束与开始"></a>结束与开始</h1>
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://anderscui.github.io/2017/07/09/text-retrieval-and-search-engines-part-2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Anders Cui">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="mathacker">
      <meta itemprop="description" content="时光中的碎片">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | mathacker">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2017/07/09/text-retrieval-and-search-engines-part-2/" class="post-title-link" itemprop="url">Text Retrieval and Search Engines(2)</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2017-07-09 01:08:41" itemprop="dateCreated datePublished" datetime="2017-07-09T01:08:41+08:00">2017-07-09</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2025-06-22 07:01:37" itemprop="dateModified" datetime="2025-06-22T07:01:37+08:00">2025-06-22</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Text-Retrieval/" itemprop="url" rel="index"><span itemprop="name">Text Retrieval</span></a>
        </span>
          , 
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Text-Retrieval/Information-Retrieval/" itemprop="url" rel="index"><span itemprop="name">Information Retrieval</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>此文内容整理自Coursera课程<a href="https://www.coursera.org/learn/text-retrieval/home/welcome">文本检索与搜索引擎（Text Retrieval and Search Engines）</a>。<a href="https://anderscui.github.io/2017/07/04/text-retrieval-and-search-engines-part-1/">Part 1笔记在此</a></p>
<p>这一部分将更详细地了解VSM，考虑它的不同优化思路，以及借助于倒排索引实现信息检索系统（即搜索引擎）。</p>
<p>主要概念：</p>
<ul>
<li>关键词词频（Term Frequency，TF）</li>
<li>文档频率（Document Frequency，DF）与逆向文档频率（Inverse DF， IDF）</li>
<li>TF transformation</li>
<li>Pivoted length normalization</li>
<li>BM25</li>
<li>倒排索引（Inverted Index）与posting</li>
<li>Binary coding，unary coding，gamma-coding和d-gap</li>
<li>Zipf法则</li>
</ul>
<p>在<a href="https://anderscui.github.io/2017/07/04/text-retrieval-and-search-engines-part-1/">Part 1</a>中介绍了”最简单的VSM“（以下简称SVSM），看下图，考虑该模型是否存在问题？</p>
<p><img src="/images/text-retrieval/problems-of-svsm.png" alt="Two Problems of the SVSM"></p>
<p>三个文档的相似度计算结果相同，但直觉上，它们应当是有差别的，比如：</p>
<ul>
<li>d4匹配到了更多关键词，应获得更高的相似度</li>
<li>d2的匹配关键词中有一个是about，d3中则有presidential，d3应该与查询更相似</li>
</ul>
<p>出现这两个问题，是因为我们使用了词袋模型和位向量，首先词频被忽略，这样高频词对相似度的贡献被忽略，接着关键词之间也被同等看待，原本贡献更高的词也泯然众“词”矣。要改进模型，可以从这两方面入手。</p>
<p>先把词频（TF）考虑进去，得到如下的向量表示法：</p>
<p><img src="/images/text-retrieval/add-tf-to-svsm.png" alt="Two Problems of the SVSM"></p>
<p>这个新的相似度计算方式可以如何解释？它是否解决了上面的两个问题？</p>
<p>计入词频后，高频词相比于低频词对相似度的贡献会更大，这符合我们的直觉。因为一个文档内，词的频率越高，它就更可能作为该文档的“主题”，而如果一个词频率太低，说不定只是凑巧“混”进了文档而已。</p>
<p>现在重新计算上面的三个文档，会发现$f(q, d2) &#x3D; 3$，$f(q, d3) &#x3D; 3$，$f(q, d4) &#x3D; 4$，它的相似度确实比d2和d3高了，而。这样我们解决了第一个问题，但第二个问题依然存在。</p>
<p>如何给不同的词赋予不同的权重呢？为什么我们会认为presidential要比about重要呢？大致可以这样理解，对于about或the这样的词，它们有很高的频率出现在各种不同主题的文档中，那么查询和文档同时出现这样的词——我们不会感到意外。可以说它们携带的信息很少，不足以区分不同的文档。但presidential就很不一样，介绍信息检索的文章（本文除外）很少会出现。</p>
<p>about这样的词，常常被称为<strong>停用词</strong>（Stopword）。我们可以考虑用某种方法来“惩罚”停用词。不过首先的问题是，如何确定哪些词属于停用词？可以统计整个文档集的所有词，如果一个词出现在了很高比例的文档中（如80%），那么它很可能是停用词。另一方面，对于像presidential这样的词，我们考虑“奖励”它，因为它们可以更好地区分文档。实现这里惩罚和奖励的常见方法是<strong>逆向文档频率</strong>（IDF）。标准的IDF实现如下：</p>
<p><img src="/images/text-retrieval/idf.png" alt="IDF"></p>
<p>$M$是文档集中的文档数量，$k$是包含词$W$的文档总数，即DF，取到数后就成了IDF。通过函数图像（曲线）可知，一个词出现在越多的文档中，其IDF越低，即得到了越多的惩罚，反之出现在越少的文档中，则会得到奖励。</p>
<p>当$k$很小时，IDF值很大，也就是说如果一个词只出现在了少数几个文档中，那么他们就会有很高的权重。当$k$逐渐增大时，IDF下降得很快，直到越过中间的转折点后，IDF就变得相当小，此时该词对于相似度而言就不甚重要了。对于about这样的词，$k$可能是接近于$M$的，它的IDF值接近于$0$。</p>
<p>引入IDF后，文档的向量公式变为：</p>
<p>$$d &#x3D; (y_1, \cdots, y_N，y_i &#x3D; c(W_i, d) * IDF(W_i)$$</p>
<p>这时再计算的话，d3的相似度就高于d2了，这样就解决了问题2。然而新的问题又出现了，看下图，d5的相似度好像有点过高了，如何解决呢：</p>
<p><img src="/images/text-retrieval/vsm-after-tfidf.png" alt="VSM after TFIDF"></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://anderscui.github.io/2017/07/04/text-retrieval-and-search-engines-part-1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Anders Cui">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="mathacker">
      <meta itemprop="description" content="时光中的碎片">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | mathacker">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2017/07/04/text-retrieval-and-search-engines-part-1/" class="post-title-link" itemprop="url">Text Retrieval and Search Engines(1)</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2017-07-04 00:34:11" itemprop="dateCreated datePublished" datetime="2017-07-04T00:34:11+08:00">2017-07-04</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2025-06-22 07:01:37" itemprop="dateModified" datetime="2025-06-22T07:01:37+08:00">2025-06-22</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Text-Retrieval/" itemprop="url" rel="index"><span itemprop="name">Text Retrieval</span></a>
        </span>
          , 
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Text-Retrieval/Information-Retrieval/" itemprop="url" rel="index"><span itemprop="name">Information Retrieval</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>此文内容整理自Coursera课程<a href="https://www.coursera.org/learn/text-retrieval/home/welcome">文本检索与搜索引擎（Text Retrieval and Search Engines）</a>。</p>
<h1 id="课程结构"><a href="#课程结构" class="headerlink" title="课程结构"></a>课程结构</h1><p><img src="/images/text-retrieval/text-retrieval-course-schedule.png" alt="Course Schedule"></p>
<h2 id="术语表"><a href="#术语表" class="headerlink" title="术语表"></a>术语表</h2><ul>
<li>Text Retrieval（TR）：文本检索</li>
<li>Information Retrieval（IR）：信息检索</li>
<li>Natural Language Processing（NLP）：自然语言处理</li>
<li>Information Need：信息需求</li>
<li>Document：文档</li>
<li>Query：查询</li>
<li>Relevance：相关度</li>
<li>Similarity：相似度</li>
<li>Ranking Function：排序函数</li>
<li>Vector Space Model（VSM）：向量空间模型</li>
<li>Term：关键词（文档中的基本概念），可以是词、短语或ngram等</li>
<li>Bag of Words（BOW）：词袋</li>
<li>Bit Vector：位向量</li>
<li>Dot Product：点积</li>
</ul>
<h1 id="1、文本检索基本概念"><a href="#1、文本检索基本概念" class="headerlink" title="1、文本检索基本概念"></a>1、文本检索基本概念</h1><p>第一部分将涵盖上图中1-5部分的内容。</p>
<h2 id="1-1-自然语言内容的分析"><a href="#1-1-自然语言内容的分析" class="headerlink" title="1.1 自然语言内容的分析"></a>1.1 自然语言内容的分析</h2><p>这无疑是处理任何文本数据的第一步，本节包含三个小主题：</p>
<ul>
<li>什么是NLP？</li>
<li>NLP领域研究的现状</li>
<li>NLP与文本检索</li>
</ul>
<h3 id="1-1-1-什么是NLP？"><a href="#1-1-1-什么是NLP？" class="headerlink" title="1.1.1 什么是NLP？"></a>1.1.1 什么是NLP？</h3><p>来看一个NLP的简单例子：</p>
<p><img src="/images/text-retrieval/an-example-of-nlp.png" alt="An example of NLP"></p>
<p>如果想让计算机理解这个句子，需要哪些步骤呢？类似于人类的理解过程，首先需要知道它包含哪些词，以及各个词的词性。这个过程称为<strong>词法分析</strong>（Lexical analysis）或<strong>词性标注</strong>（Part-of-speech tagging）。</p>
<p>接下来需要了解句子的语法结构，即这些词如何构成更复杂的语法结构。如A和dog构成名词短语，on、the及playground构成介词短语等等。这个过程称为<strong>语法分析</strong>（Syntactic analysis）。</p>
<p>了解了句子的词法结构和语法结构，计算机仍不足以了解句子的意义。这时需要的是<strong>语义分析</strong>（Semantic analysis）。对计算机来说，需要将词和短语这样的成分对应到某些symbol，同时还要有symbol之间的关系，比如上图中的Chasing就是这样一种关系。更进一步，在关系之上，我们还可以进行<strong>推理</strong>（Inference），比如我们有一条规则：如果某实体被狗追，那么该实体会害怕。在此规则下，我们可以推理出一个结论：the boy is scared。</p>
<p>另外还可以考虑，一个人为何说出这样一句话？ta的意图是什么？一种可能是，ta在提醒另一个人把狗牵回来。这个过程称为<strong>Pragmatic analysis</strong>，即分析“语言行为“本身。</p>
<p>计算机要理解一个如此简单的句子都需要很繁琐的过程。人类理解起来要容易得多，这是因为人的大脑早已有了庞大的”知识“库，而计算机则需要从头学起。</p>
<p>直觉上，人类学习语言并非如洛克的”白板论”那样，一个人对于语言的理解应当有相当的部分来自于遗传。总之，对于可怜的计算机而言，NLP是很难的。</p>
<h3 id="1-1-2-NLP是很难的"><a href="#1-1-2-NLP是很难的" class="headerlink" title="1.1.2 NLP是很难的"></a>1.1.2 NLP是很难的</h3><p>”自然语言“当然是为人类的有效沟通而设计，其结果是：我们会大量的”<strong>常识</strong>“内容，并假设听者或读者是能够理解的；语言中存在大量的<strong>歧义</strong>（ambiguity），我们假设听者或读者能够仔细理解之。</p>
<p>当一个人缺乏<strong>常识</strong>，与ta沟通起来会感觉困难。对NLP来说，以Siri之类的应用为例，我们的感觉不是与它很难沟通，而是完全无法沟通。当一个人说的话有<strong>歧义</strong>，人类也会觉得理解起来有困难，拿不准其准确含义，遑论计算机了。所以，常识的缺乏和歧义使得NLP格外困难。</p>
<p>歧义的常见情况有：</p>
<ul>
<li>词的歧义：不同词性；多义词；</li>
<li>语法结构的歧义：修饰语与被修饰语的不同结合；介词短语附着（PP Attachment），”A man saw a boy <em>with a telescope</em>；</li>
<li>首语重复（Anaphora）解析：John persuaded Bill to buy a TV for <em>himself</em>；</li>
<li>预先假定（Presupposition）：”He has quit smoking”暗示他曾吸过烟。</li>
</ul>
<h3 id="1-1-3-NLP研究现状"><a href="#1-1-3-NLP研究现状" class="headerlink" title="1.1.3 NLP研究现状"></a>1.1.3 NLP研究现状</h3><p><img src="/images/text-retrieval/state-of-the-art-nlp.png" alt="State of the Art NLP"></p>
<p>词性标注准确率较高；语法解析层面，部分解析（Partial Parsing，即句子的一部分，如短语级别）达到90%以上。</p>
<p>语义解析的进展则相当不好。不过在某些特定应用上取得了一些进展，如实体识别、关系提取、情感分析。</p>
<p>推理和语言行为方面的表现则是更差。</p>
<p>值得一提的是，尽管说词性标注和部分解析的准确率已经达到较高的程度，但这些评测都是基于特定的测试数据集，此类测试集常常是新闻类数据，这会导致一定的偏差。因此相应的算法应用到不同领域中可能未必有同样好的效果。</p>
<h3 id="1-1-4-NLP与文本检索"><a href="#1-1-4-NLP与文本检索" class="headerlink" title="1.1.4 NLP与文本检索"></a>1.1.4 NLP与文本检索</h3><p>文本检索通常涉及大量而广泛的文本，如果希望其中的NLP技术是健壮和高效的，那么目前来看只能采用浅层的NLP。文本的<strong>词袋</strong>（Bag of Words）表示是最简单的一种，它无疑丢弃了文本的大量信息，但对于大部分（不是全部）搜索任务而言却是够用的。</p>
<p>某些文本检索技术可以自然地解决NLP问题，如语义消歧。</p>
<p>但是，对于复杂的搜索任务，更深层的NLP技术仍是必需的，比如<strong>知识图谱</strong>（Knowledge Graph）。</p>
<h2 id="1-2-文本访问"><a href="#1-2-文本访问" class="headerlink" title="1.2 文本访问"></a>1.2 文本访问</h2><p>一个文本信息系统该如何让用户访问到他们关心的（或相关的，relevant）数据？这里主要考虑两种模式。</p>
<ul>
<li>Pull模式（搜索引擎）：由用户发起。用户在系统中根据特定的需求开始查询，并浏览相应的结果。此时的需求往往是临时性的，比如查询某个术语、某个作者或一类商品的信息。这种情形下，系统很难预知用户的需求，因此Pull模式较为适合。</li>
<li>Push模式（推荐系统）：由系统发起。如果用户有某种较固定的需求，而且系统对用户比较了解，那么系统可以主动向用户push信息。比如Pocket app在用户使用一段时间后，可以向用户推荐其感兴趣的文章。</li>
</ul>
<p>在pull模式下，也存在两种不同的方式：</p>
<ul>
<li>Querying：用户对自己的需求比较清楚，知道该如何查询。比如当我们知道书名或作者名时，可以直接查询。</li>
<li>Browsing：用户对需求不甚清楚，希望先在系统中漫游一番。当我们遇到某书店的打折信息，满200减100，但暂时并没有特定要买的书，这时往往从分类或主题开始浏览。</li>
</ul>
<p>尽管说Browsing属于pull模式，但仔细想想，当用户不太清楚想要什么时，不正是推荐系统发挥作用的地方吗？</p>
<h2 id="1-3-TR中的问题"><a href="#1-3-TR中的问题" class="headerlink" title="1.3 TR中的问题"></a>1.3 TR中的问题</h2><p>本节包含三个小主题：</p>
<ul>
<li>什么是文本检索？</li>
<li>文本检索 vs. 数据库检索</li>
<li>文档选择（Selection） vs. 文档排序（Ranking）</li>
</ul>
<h3 id="1-3-1-什么是文本检索？"><a href="#1-3-1-什么是文本检索？" class="headerlink" title="1.3.1 什么是文本检索？"></a>1.3.1 什么是文本检索？</h3><p>对于使用过搜索引擎的人来说，这甚至算不上是一个问题：）</p>
<p>系统已收集大量（具体的量级视具体问题而定）文档。用户发起查询，表达自己的<strong>信息需求</strong>（Information Need）。系统返回相关文档给用户。这就是high level的文本检索过程。</p>
<p>文本检索也被称为<strong>信息检索</strong>（Information Retrieval，IR），但实际上IR的范围更广，因为其数据可能是非文本的。文本检索在业界被称为“搜索技术”。</p>
<h3 id="1-3-2-文本检索-vs-数据库检索"><a href="#1-3-2-文本检索-vs-数据库检索" class="headerlink" title="1.3.2 文本检索 vs. 数据库检索"></a>1.3.2 文本检索 vs. 数据库检索</h3><p>这里将两者简称为TR和DR，并从不同的角度来看：</p>
<ol>
<li>信息：TR是非结构化的、模糊的；DR是结构化的、具有良好语义的；</li>
<li>查询：TR是模糊的、不完整的；DR是具有良好语义的、完整的；</li>
<li>返回结果：TR是<strong>相关的文档</strong>，DR是<strong>匹配的记录</strong>；</li>
<li>TR是基于经验的，不能以数学的方式精确判断一直方法的好坏，因此需要借助于用户的介入以评测方法的表现。比如通过用户对于查询结果的后续操作来判断其好坏。</li>
</ol>
<p>下图是TR的正式定义：</p>
<p><img src="/images/text-retrieval/formal-formulation-of-tr.png" alt="Formal formulation of TR"></p>
<p><code>R(q)</code>是一次用户查询的相关文档构成的集合，但一般情况下，它是不可知的，同时也依赖于具体的用户。在此前提下，我们的任务是<strong>计算它的近似值</strong>。</p>
<h3 id="1-3-3-文档选择-vs-文档排序"><a href="#1-3-3-文档选择-vs-文档排序" class="headerlink" title="1.3.3 文档选择 vs. 文档排序"></a>1.3.3 文档选择 vs. 文档排序</h3><p>上述任务的两种策略是：</p>
<ul>
<li>文档选择：通过某个函数或二元分类器来确定一个文档是否属于目标集合。对于<code>C</code>中的每一个文档，它的结果只能是属于或不属于。这里的结果是<strong>绝对相关度</strong>（absolute relevance）。</li>
<li>文档排序：选择某个相关度度量函数，对每个文档判断它在多大程度上与当前用户查询是相关的。这里的结果是<strong>相对相关度</strong>（relative relevance）。</li>
</ul>
<p>文档选择必须要严格确定出，一个文档是否是相关的；而文档排序则只需要给出相对的相关对，由用户来决定阈值。现实中，后者也确实更可取的方法。</p>
<p>文档选择法存在固有的问题。其分类器很难达到特别准确的程度，要么过于严格而返回过少的文档，要么过于宽松而返回过多的文档。另一方面，即使它是准确的，所返回的”相关文档“的相关度理应是不同的，而分类器没办法确定出来。</p>
<p>文档排序法的依据来自于<strong>概率排序原理</strong>（Probability ranking principle），即在如下两个假设下，按文档对于查询的相关度降序排列的列表是最佳策略：</p>
<ul>
<li>文档对于用户的价值（utility）相互之间是不相关的</li>
<li>用户会顺序浏览结果</li>
</ul>
<p>实际上，这两个假设都不一定为真。比如，如果两个文档内容接近，那么用户看过一个后，对于第二个就没有太大兴趣了；用户会跳过部分文档。这两种情况在使用Google之类的搜索引擎时都会遇到。</p>
<h2 id="1-4-文本检索方法"><a href="#1-4-文本检索方法" class="headerlink" title="1.4 文本检索方法"></a>1.4 文本检索方法</h2><p>文本检索的定义可见于1.3.2中的图片。简言之，我们需要找到一个合适的<strong>排序函数</strong>（ranking function）。当前常见的检索模型有：</p>
<ul>
<li>基于相似度（similarity）的模型：Vector space model</li>
<li>概率模型：经典概率模型；Language model；Divergence-from-randomness模型</li>
<li>Probabilistic inference model</li>
<li>Axiomatic model</li>
</ul>
<p>本课程主要涉及<strong>向量空间模型</strong>（VSM）和语言模型（Language model）。有趣的是，尽管上述诸方法的思路颇不相同，但其最终的模型形式却是很相似的。</p>
<p>那么，哪一种模型是最好的？答案是，在优化之后，下面几种模型的表现同样好：</p>
<ul>
<li>Pivoted length normalization</li>
<li>BM25</li>
<li>Query likelihood</li>
<li>PL2</li>
</ul>
<p>BM25是其中最流行。这些模型涉及到的重要概念有：词袋表示、TF、DF和文档长度。</p>
<h2 id="1-5-向量空间模型"><a href="#1-5-向量空间模型" class="headerlink" title="1.5 向量空间模型"></a>1.5 向量空间模型</h2><p>VSM是基于相似度的一种模型。所谓基于相似度，是指它以文档和查询之间的<strong>相似度</strong>来度量<strong>相关度</strong>。</p>
<p>为计算相似度，我们把文档和查询都<strong>表示为向量空间中的向量</strong>，如下图所示：</p>
<p><img src="/images/text-retrieval/vsm.png" alt="Vector space model"></p>
<p>文档$d_1$表示为Library和Presidential两个关键词（term），$d_2$表示为Programming和Library两个term（很可能，这里的Library是指编程中的”库“），而查询$q$看起来与$d_2$最相似，那么按VSM模型，与该查询相关度最高的文档是$d_2$。</p>
<p>下面给出VSM更正式的定义。VSM是一个框架：</p>
<ul>
<li>将文档和查询表示为term vector<ul>
<li>Term：关键词（文档中的基本概念），可以是词、短语或ngram</li>
<li>每个term定义为一个维度</li>
<li>N个term就定义了一个N维空间</li>
<li>查询向量：$q &#x3D; (x_1, \dots, x_N), x_i \in R$，这里的$x_i$表示查询在相应维度上的权重（weight）</li>
<li>文档向量：$d &#x3D; (y_1, \dots, y_N), y_i \in R$，这里的$y_i$表示文档在相应维度上的权重（weight）</li>
</ul>
</li>
<li>相关度$relevance(q, d)$转化为$similarity(q, d) &#x3D; f(q, d)$</li>
</ul>
<p>之所以说VSM是一个框架，是因为这里实际上没有给出任何与具体实现相关的细节。要找到这里的$f$我们还需要考虑：</p>
<ul>
<li>如何定义或选择关键词？<ul>
<li>它们需要是正交的（orthogonal）</li>
</ul>
</li>
<li>如何为查询和文档向量设置合适的权重？</li>
<li>如何度量相似度？</li>
</ul>
<h2 id="1-6-VSM的最简单实现"><a href="#1-6-VSM的最简单实现" class="headerlink" title="1.6 VSM的最简单实现"></a>1.6 VSM的最简单实现</h2><p>VSM的最简单实现是位向量（Bit Vector），即用一个布尔值表示一个term是否出现在了文档中。如果term$w_i$未出现，那么$y_i &#x3D; 0$，否则$y_i &#x3D; 1$。而查询也以同样的方式表示。</p>
<p>这种方式的特点之一是，它忽略了一个term在文档中出现的具体次数。另外，当文档集较大（一般都是如此）时，向量维度变得较高，从而使得文档和查询的向量变得很稀疏，即出现大量的0。</p>
<p>这样，文档与查询的相似度可表示为两者向量的<strong>点积</strong>（Dot Product）：</p>
<p>$$Sim(q, d) &#x3D; q.d &#x3D; \sum_{i&#x3D;1}^{N}x_i y_i$$</p>
<p><img src="/images/text-retrieval/bit-vector.png" alt="Vector space model"></p>
<p>在这个例子中，$V$表示文档集中所有term构成的”词汇表“。然后我们列出查询与文档的位向量，然后计算其点积。从结果来看，d2的相似度高于d1。看起来还蛮合理的，这就是我们”最简单的VSM“，它可以总结为：BOW + Bit Vector + Dot Product，编程实现足够简单，只要一个类似于jieba之类的分词工具即可。</p>
<p>那么这里点积的结果作何解释呢？点积的计算结果恰好表示了，同时出现在文档和查询中的term的数量。虽然它有时比较合理，但也会产生一些问题。比如，它只计数共同出现的term数量，数量相同的就没法区分了，也就是说对所有term一视同仁，这与我们的直觉不符，因为某些term应该是更重要的，而像the、about这样的term则不能对相似度提供什么帮助。</p>
<p>后续的课程会介绍不这么简单的VSM：）</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




  <nav class="pagination">
    <a class="extend prev" rel="prev" title="Previous page" aria-label="Previous page" href="/page/2/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><span class="page-number current">3</span><a class="page-number" href="/page/4/">4</a><a class="extend next" rel="next" title="Next page" aria-label="Next page" href="/page/4/"><i class="fa fa-angle-right"></i></a>
  </nav>

</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="copyright">
    &copy; 
    <span itemprop="copyrightYear">2025</span>
    <span class="with-love">
      <i class="fa fa-heart"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">Anders Cui</span>
  </div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/muse/" rel="noopener" target="_blank">NexT.Muse</a>
  </div>

    </div>
  </footer>

  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>
  <div class="sidebar-dimmer"></div>
  <div class="back-to-top" role="button" aria-label="Back to top">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>

</body>
</html>
